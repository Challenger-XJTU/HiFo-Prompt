{
     "algorithm": "```",
     "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def calculate_mst_cost(nodes, dist_matrix):\n        from scipy.sparse.csgraph import minimum_spanning_tree\n        sub_matrix = dist_matrix[np.ix_(nodes, nodes)]\n        mst = minimum_spanning_tree(sub_matrix)\n        return mst.sum()\n\n    def evaluate_node(next_node, current_node, unvisited, dist_matrix):\n        immediate_cost = dist_matrix[current_node, next_node]\n        mst_cost = calculate_mst_cost([destination_node] + [n for n in unvisited if n != next_node], dist_matrix)\n        normalized_cost = immediate_cost / (np.mean(dist_matrix[current_node]) + 1e-6)\n        return immediate_cost + mst_cost + normalized_cost\n\n    candidate_set = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])[:5]\n    scored_candidates = [(node, evaluate_node(node, current_node, unvisited_nodes, distance_matrix)) for node in candidate_set]\n    next_node = min(scored_candidates, key=lambda x: x[1])[0]\n    return next_node",
     "objective": 6.30481,
     "other_inf": null,
     "metadata": {
          "operator": "m3",
          "insights": [
               "Use statistical exploration and look-ahead evaluation to iteratively refine candidate sets, ensuring diverse and high-quality partial solutions while maintaining adaptability for future optimization steps.",
               "Combine immediate decision metrics with global structural insights to guide solution refinement dynamically.",
               "Leverage statistical reasoning and diverse path exploration to balance exploitation and exploration effectively."
          ],
          "attention_focus": "optimizing established successful strategies and patterns",
          "generation_tendency": "balanced_search",
          "timestamp": 1769698299.044307
     }
}