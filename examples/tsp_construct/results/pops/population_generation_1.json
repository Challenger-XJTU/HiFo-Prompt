[
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def calculate_mst_cost(nodes, dist_matrix):\n        from scipy.sparse.csgraph import minimum_spanning_tree\n        sub_matrix = dist_matrix[np.ix_(nodes, nodes)]\n        mst = minimum_spanning_tree(sub_matrix)\n        return mst.sum()\n\n    def evaluate_node(next_node, current_node, unvisited, dist_matrix):\n        immediate_cost = dist_matrix[current_node, next_node]\n        mst_cost = calculate_mst_cost([destination_node] + [n for n in unvisited if n != next_node], dist_matrix)\n        normalized_cost = immediate_cost / (np.mean(dist_matrix[current_node]) + 1e-6)\n        return immediate_cost + mst_cost + normalized_cost\n\n    candidate_set = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])[:5]\n    scored_candidates = [(node, evaluate_node(node, current_node, unvisited_nodes, distance_matrix)) for node in candidate_set]\n    next_node = min(scored_candidates, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.30481,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "insights": [
                    "Use statistical exploration and look-ahead evaluation to iteratively refine candidate sets, ensuring diverse and high-quality partial solutions while maintaining adaptability for future optimization steps.",
                    "Combine immediate decision metrics with global structural insights to guide solution refinement dynamically.",
                    "Leverage statistical reasoning and diverse path exploration to balance exploitation and exploration effectively."
               ],
               "attention_focus": "optimizing established successful strategies and patterns",
               "generation_tendency": "balanced_search",
               "timestamp": 1769698299.044307
          }
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def calculate_mst_cost(nodes, dist_matrix):\n        from scipy.sparse.csgraph import minimum_spanning_tree\n        sub_matrix = dist_matrix[np.ix_(nodes, nodes)]\n        mst = minimum_spanning_tree(sub_matrix)\n        return mst.sum()\n\n    def evaluate_node(next_node, current_node, unvisited, dist_matrix, progress_ratio):\n        immediate_cost = dist_matrix[current_node, next_node]\n        future_cost = min(dist_matrix[next_node, n] for n in unvisited if n != next_node) if len(unvisited) > 1 else 0\n        mst_cost = calculate_mst_cost([destination_node] + [n for n in unvisited if n != next_node], dist_matrix)\n        normalized_cost = immediate_cost / (np.mean(dist_matrix[current_node]) + 1e-6)\n        \n        # Adaptive weighting based on progress ratio\n        w1 = 0.5 - 0.3 * progress_ratio  # Immediate cost weight\n        w2 = 0.2 + 0.2 * progress_ratio  # Future cost weight\n        w3 = 0.3                        # MST cost weight\n        \n        return w1 * immediate_cost + w2 * future_cost + w3 * mst_cost + 0.1 * normalized_cost\n\n    total_nodes = len(distance_matrix)\n    progress_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    candidate_set = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])[:3]\n    scored_candidates = [(node, evaluate_node(node, current_node, unvisited_nodes, distance_matrix, progress_ratio)) for node in candidate_set]\n    next_node = min(scored_candidates, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.31592,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "insights": [
                    "Use statistical exploration and look-ahead evaluation to iteratively refine candidate sets, ensuring diverse and high-quality partial solutions while maintaining adaptability for future optimization steps.",
                    "Combine immediate decision metrics with global structural insights to guide solution refinement dynamically.",
                    "Leverage statistical reasoning and diverse path exploration to balance exploitation and exploration effectively."
               ],
               "attention_focus": "reducing unnecessary computational overhead and redundancy",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1769698311.001739
          }
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def calculate_mst_cost(nodes, dist_matrix):\n        from scipy.sparse.csgraph import minimum_spanning_tree\n        sub_matrix = dist_matrix[np.ix_(nodes, nodes)]\n        mst = minimum_spanning_tree(sub_matrix)\n        return mst.sum()\n\n    def evaluate_node(next_node, current_node, unvisited, dist_matrix, progress_ratio):\n        immediate_cost = dist_matrix[current_node, next_node]\n        future_cost = min(dist_matrix[next_node, n] for n in unvisited if n != next_node) if len(unvisited) > 1 else 0\n        mst_cost = calculate_mst_cost([destination_node] + [n for n in unvisited if n != next_node], dist_matrix)\n        normalized_cost = immediate_cost / (np.mean(dist_matrix[current_node]) + 1e-6)\n        \n        # Adaptive weighting based on progress ratio\n        w1 = 0.5 + 0.2 * progress_ratio  # Immediate cost weight\n        w2 = 0.3 - 0.1 * progress_ratio  # Future cost weight\n        w3 = 0.2 - 0.1 * progress_ratio  # MST cost weight\n        \n        return w1 * immediate_cost + w2 * future_cost + w3 * mst_cost + 0.1 * normalized_cost\n\n    total_nodes = len(distance_matrix)\n    progress_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    candidate_set = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])[:5]\n    scored_candidates = [(node, evaluate_node(node, current_node, unvisited_nodes, distance_matrix, progress_ratio)) for node in candidate_set]\n    next_node = min(scored_candidates, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.46225,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "insights": [
                    "Use statistical exploration and look-ahead evaluation to iteratively refine candidate sets, ensuring diverse and high-quality partial solutions while maintaining adaptability for future optimization steps.",
                    "Combine immediate decision metrics with global structural insights to guide solution refinement dynamically.",
                    "Leverage statistical reasoning and diverse path exploration to balance exploitation and exploration effectively."
               ],
               "attention_focus": "optimizing established successful strategies and patterns",
               "generation_tendency": "balanced_search",
               "timestamp": 1769698311.82196
          }
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def calculate_mst_cost(nodes, dist_matrix):\n        from scipy.sparse.csgraph import minimum_spanning_tree\n        sub_matrix = dist_matrix[np.ix_(nodes, nodes)]\n        mst = minimum_spanning_tree(sub_matrix)\n        return mst.sum()\n\n    def simulate_path(start, remaining, steps=3):\n        if steps == 0 or len(remaining) == 0:\n            return 0\n        candidates = sorted(remaining, key=lambda x: distance_matrix[start, x])[:2]\n        return min(distance_matrix[start, c] + simulate_path(c, [n for n in remaining if n != c], steps - 1) for c in candidates)\n\n    def evaluate_node(next_node, current_node, unvisited, dist_matrix):\n        immediate_cost = dist_matrix[current_node, next_node]\n        future_cost = simulate_path(next_node, [n for n in unvisited if n != next_node])\n        mst_cost = calculate_mst_cost([destination_node] + [n for n in unvisited if n != next_node], dist_matrix)\n        normalized_cost = immediate_cost / (np.median(dist_matrix[current_node]) + 1e-6)\n        return immediate_cost + 0.7 * future_cost + 1.0 * mst_cost + 0.3 * normalized_cost\n\n    candidate_set = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])[:5]\n    scored_candidates = [(node, evaluate_node(node, current_node, unvisited_nodes, distance_matrix)) for node in candidate_set]\n    next_node = min(scored_candidates, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.46673,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "insights": [
                    "Use statistical exploration and look-ahead evaluation to iteratively refine candidate sets, ensuring diverse and high-quality partial solutions while maintaining adaptability for future optimization steps.",
                    "Combine immediate decision metrics with global structural insights to guide solution refinement dynamically.",
                    "Leverage statistical reasoning and diverse path exploration to balance exploitation and exploration effectively."
               ],
               "attention_focus": "optimizing established successful strategies and patterns",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1769698310.2470121
          }
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def calculate_mst_cost(nodes, dist_matrix):\n        from scipy.sparse.csgraph import minimum_spanning_tree\n        sub_matrix = dist_matrix[np.ix_(nodes, nodes)]\n        mst = minimum_spanning_tree(sub_matrix)\n        return mst.sum()\n\n    def evaluate_node(next_node, current_node, unvisited, dist_matrix, progress_ratio):\n        immediate_cost = dist_matrix[current_node, next_node]\n        mst_cost = calculate_mst_cost([destination_node] + [n for n in unvisited if n != next_node], dist_matrix)\n        normalized_cost = immediate_cost / (np.mean(dist_matrix[current_node]) + 1e-6)\n        \n        # Adaptive weighting based on progress ratio\n        w1 = 0.5 + 0.3 * progress_ratio  # Immediate cost weight\n        w2 = 0.5 - 0.3 * progress_ratio  # MST cost weight\n        \n        return w1 * immediate_cost + w2 * mst_cost + 0.1 * normalized_cost\n\n    total_nodes = len(distance_matrix)\n    progress_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    candidate_set = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])[:5]\n    scored_candidates = [(node, evaluate_node(node, current_node, unvisited_nodes, distance_matrix, progress_ratio)) for node in candidate_set]\n    next_node = min(scored_candidates, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.5264,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "insights": [
                    "Use statistical exploration and look-ahead evaluation to iteratively refine candidate sets, ensuring diverse and high-quality partial solutions while maintaining adaptability for future optimization steps.",
                    "Combine immediate decision metrics with global structural insights to guide solution refinement dynamically.",
                    "Leverage statistical reasoning and diverse path exploration to balance exploitation and exploration effectively."
               ],
               "attention_focus": "introducing new randomization or adaptive mechanisms",
               "generation_tendency": "balanced_search",
               "timestamp": 1769698313.721926
          }
     },
     {
          "algorithm": "The new algorithm refines node selection by adaptively weighting immediate costs, future path simulations, MST-based global connectivity, and learned distance patterns while dynamically adjusting scoring weights based on search progress.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def calculate_mst_cost(nodes, dist_matrix):\n        from scipy.sparse.csgraph import minimum_spanning_tree\n        sub_matrix = dist_matrix[np.ix_(nodes, nodes)]\n        mst = minimum_spanning_tree(sub_matrix)\n        return mst.sum()\n\n    def simulate_path(start, remaining, steps=3):\n        if steps == 0 or len(remaining) == 0:\n            return 0\n        candidates = sorted(remaining, key=lambda x: distance_matrix[start, x])[:5]\n        return min(distance_matrix[start, c] + simulate_path(c, [n for n in remaining if n != c], steps - 1) for c in candidates)\n\n    def evaluate_node(next_node, current_node, unvisited, dist_matrix, progress_ratio):\n        immediate_cost = dist_matrix[current_node, next_node]\n        future_cost = simulate_path(next_node, [n for n in unvisited if n != next_node])\n        mst_cost = calculate_mst_cost([destination_node] + [n for n in unvisited if n != next_node], dist_matrix)\n        normalized_cost = immediate_cost / (np.mean(dist_matrix[current_node]) + 1e-6)\n        \n        # Adaptive weighting based on progress ratio\n        w1 = 0.4 + 0.3 * progress_ratio  # Immediate cost weight\n        w2 = 0.3 - 0.2 * progress_ratio  # Future cost weight\n        w3 = 0.2 - 0.1 * progress_ratio  # MST cost weight\n        w4 = 0.1                       # Normalized cost weight\n        \n        return w1 * immediate_cost + w2 * future_cost + w3 * mst_cost + w4 * normalized_cost\n\n    total_nodes = len(distance_matrix)\n    progress_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    candidate_set = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])[:5]\n    scored_candidates = [(node, evaluate_node(node, current_node, unvisited_nodes, distance_matrix, progress_ratio)) for node in candidate_set]\n    next_node = min(scored_candidates, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.56098,
          "other_inf": null,
          "metadata": {
               "operator": "m1",
               "insights": [
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features",
                    "Employ machine learning or pattern recognition to mine deep problem structures and optimal solution patterns then use learned insights to intelligently bias towards promising search regions or constructive choices",
                    "Explore objective function engineering by introducing auxiliary or surrogate objectives or by dynamically adjusting weights to reshape the search landscape aiding escape from local optima or guiding diverse exploration"
               ],
               "attention_focus": "refining core evaluation and scoring functions",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1769698175.821455
          }
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def calculate_mst_cost(nodes, dist_matrix):\n        from scipy.sparse.csgraph import minimum_spanning_tree\n        sub_matrix = dist_matrix[np.ix_(nodes, nodes)]\n        mst = minimum_spanning_tree(sub_matrix)\n        return mst.sum()\n\n    def evaluate_node(next_node, current_node, unvisited, dist_matrix, progress_ratio):\n        immediate_cost = dist_matrix[current_node, next_node]\n        mst_cost = calculate_mst_cost([destination_node] + [n for n in unvisited if n != next_node], dist_matrix)\n        normalized_cost = immediate_cost / (np.mean(dist_matrix[current_node]) + 1e-6)\n        \n        # Simplified adaptive weighting\n        w1 = 0.6 - 0.4 * progress_ratio  # Immediate cost weight\n        w2 = 0.3 + 0.2 * progress_ratio  # MST cost weight\n        w3 = 0.1                        # Normalized cost weight\n        \n        return w1 * immediate_cost + w2 * mst_cost + w3 * normalized_cost\n\n    total_nodes = len(distance_matrix)\n    progress_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    candidate_set = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])[:3]\n    scored_candidates = [(node, evaluate_node(node, current_node, unvisited_nodes, distance_matrix, progress_ratio)) for node in candidate_set]\n    next_node = min(scored_candidates, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.59975,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "insights": [
                    "Use statistical exploration and look-ahead evaluation to iteratively refine candidate sets, ensuring diverse and high-quality partial solutions while maintaining adaptability for future optimization steps.",
                    "Combine immediate decision metrics with global structural insights to guide solution refinement dynamically.",
                    "Leverage statistical reasoning and diverse path exploration to balance exploitation and exploration effectively."
               ],
               "attention_focus": "optimizing objective function evaluation criteria",
               "generation_tendency": "balanced_search",
               "timestamp": 1769698299.11933
          }
     },
     {
          "algorithm": "The new algorithm dynamically balances immediate costs, future path quality, MST-based global connectivity, and normalized edge costs while emphasizing early-stage exploration and late-stage exploitation through adaptive parameter weighting.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def calculate_mst_cost(nodes, dist_matrix):\n        from scipy.sparse.csgraph import minimum_spanning_tree\n        sub_matrix = dist_matrix[np.ix_(nodes, nodes)]\n        mst = minimum_spanning_tree(sub_matrix)\n        return mst.sum()\n\n    def simulate_path(start, remaining, steps=2):\n        if steps == 0 or len(remaining) == 0:\n            return 0\n        candidates = sorted(remaining, key=lambda x: distance_matrix[start, x])[:3]\n        return min(distance_matrix[start, c] + simulate_path(c, [n for n in remaining if n != c], steps - 1) for c in candidates)\n\n    def evaluate_node(next_node, current_node, unvisited, dist_matrix, progress_ratio):\n        immediate_cost = dist_matrix[current_node, next_node]\n        future_cost = simulate_path(next_node, [n for n in unvisited if n != next_node])\n        mst_cost = calculate_mst_cost([destination_node] + [n for n in unvisited if n != next_node], dist_matrix)\n        normalized_cost = immediate_cost / (np.mean(dist_matrix[current_node]) + 1e-6)\n        \n        # Adaptive weighting based on progress ratio\n        w1 = 0.5 - 0.3 * progress_ratio  # Immediate cost weight\n        w2 = 0.2 + 0.2 * progress_ratio  # Future cost weight\n        w3 = 0.2 + 0.1 * progress_ratio  # MST cost weight\n        w4 = 0.1                       # Normalized cost weight\n        \n        return w1 * immediate_cost + w2 * future_cost + w3 * mst_cost + w4 * normalized_cost\n\n    total_nodes = len(distance_matrix)\n    progress_ratio = (total_nodes - len(unvisited_nodes)) / total_nodes\n    candidate_set = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node, x])[:3]\n    scored_candidates = [(node, evaluate_node(node, current_node, unvisited_nodes, distance_matrix, progress_ratio)) for node in candidate_set]\n    next_node = min(scored_candidates, key=lambda x: x[1])[0]\n    return next_node",
          "objective": 6.60092,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "insights": [
                    "Combine greedy local decisions with global structural reasoning by leveraging properties such as minimum spanning trees and clustering effects to guide solution construction.",
                    "Use statistical exploration and scoring mechanisms, inspired by methods like Monte Carlo Tree Search, to evaluate and prioritize promising alternatives while maintaining diversity in the search space.",
                    "Use statistical exploration and look-ahead evaluation to iteratively refine candidate sets, ensuring diverse and high-quality partial solutions while maintaining adaptability for future optimization steps."
               ],
               "attention_focus": "reducing unnecessary computational overhead and redundancy",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1769698244.646059
          }
     }
]