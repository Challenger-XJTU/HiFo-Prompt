{
     "algorithm": "node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {",
     "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {}\n    adaptive_weight = np.random.uniform(0.7, 1.3)  # Reduced range for stability\n    for candidate in candidates:\n        look_ahead_cost = evaluate_candidate(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = distance_matrix[current_node][candidate] / (np.median(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (adaptive_weight * look_ahead_cost) + (0.6 * mst_remaining) + (0.4 * normalized_cost)\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
     "objective": 6.07493,
     "other_inf": null,
     "metadata": {
          "operator": "m3",
          "wisdom_tips": [
               "Combine structural insights (e.g., MST-based cost modeling) with greedy heuristics to guide decision-making while preserving global solution quality.",
               "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations.",
               "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
          ],
          "attention_focus": "exploring novel solution construction methodologies",
          "generation_tendency": "balanced_search",
          "timestamp": 1758182497.993067
     }
}