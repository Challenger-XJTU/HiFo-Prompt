[
     {
          "algorithm": "A new algorithm that uses adaptive cluster-aware lookahead and structural diversity scoring to prioritize nodes, reducing computational overhead by pruning redundant evaluations.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_score(node):\n        neighbors = sorted(unvisited_nodes, key=lambda x: distance_matrix[node][x])[:3]\n        return np.mean([distance_matrix[node][n] for n in neighbors])\n    \n    def lookahead_cost(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_score(node):\n        neighbors = sorted(unvisited_nodes, key=lambda x: distance_matrix[node][x])[:3]\n        return np.mean([distance_matrix[node][n] for n in neighbors])\n    \n    def lookahead_cost(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {}\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        cluster_quality = cluster_score(candidate)\n        future_cost = lookahead_cost(candidate)\n        normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (\n            0.5 * future_cost +\n            0.3 * cluster_quality +\n            0.2 * normalized_cost\n        )\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.96144,
          "other_inf": null,
          "metadata": {
               "operator": "e2",
               "wisdom_tips": [
                    "Combine greedy local decisions with global structural insights to guide the search process effectively.",
                    "Use adaptive weighting and lookahead strategies to balance exploration in early stages with exploitation in later stages.",
                    "Integrate machine learning and domain-specific heuristics to dynamically adjust decision weights, ensuring exploration-exploitation trade-offs align with problem progress."
               ],
               "attention_focus": "reducing unnecessary computational overhead and redundancy",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758183783.619864
          }
     },
     {
          "algorithm": "The new algorithm selects the next node by balancing greedy local decisions with global path coherence using adaptive lookahead, normalized edge costs, and cluster-aware momentum while maintaining a beam of diverse candidate paths for robustness.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_score(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n\n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n\n    def beam_search_candidates():\n        candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n        beams = []\n        for candidate in candidates:\n            direct_cost = distance_matrix[current_node][candidate]\n            lookahead_cost = lookahead_evaluation(candidate)\n            cluster_quality = cluster_score(candidate)\n            normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n            score = (\n                0.4 * lookahead_cost +\n                0.3 * cluster_quality +\n                0.2 * normalized_cost +\n                0.1 * direct_cost\n            )\n            beams.append((score, candidate))\n        beams.sort(key=lambda x: x[0])\n        return [node for _, node in beams[:min(3, len(beams))]]\n\n    candidate_beam = beam_search_candidates()\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_score(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n\n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n\n    def beam_search_candidates():\n        candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n        beams = []\n        for candidate in candidates:\n            direct_cost = distance_matrix[current_node][candidate]\n            lookahead_cost = lookahead_evaluation(candidate)\n            cluster_quality = cluster_score(candidate)\n            normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n            score = (\n                0.4 * lookahead_cost +\n                0.3 * cluster_quality +\n                0.2 * normalized_cost +\n                0.1 * direct_cost\n            )\n            beams.append((score, candidate))\n        beams.sort(key=lambda x: x[0])\n        return [node for _, node in beams[:min(3, len(beams))]]\n\n    candidate_beam = beam_search_candidates()\n    scores = {}\n    for candidate in candidate_beam:\n        direct_cost = distance_matrix[current_node][candidate]\n        lookahead_cost = lookahead_evaluation(candidate)\n        cluster_quality = cluster_score(candidate)\n        normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (\n            0.5 * lookahead_cost +\n            0.3 * cluster_quality +\n            0.2 * normalized_cost\n        )\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.97729,
          "other_inf": null,
          "metadata": {
               "operator": "m1",
               "wisdom_tips": [
                    "Combine greedy local decisions with global structural insights to guide the search process effectively.",
                    "Use adaptive weighting and lookahead strategies to balance exploration in early stages with exploitation in later stages.",
                    "Combine short-term decision metrics with long-term structural considerations to guide incremental progress toward an optimal solution."
               ],
               "attention_focus": "improving algorithm robustness across different problem instances",
               "generation_tendency": "balanced_search",
               "timestamp": 1758183854.375092
          }
     },
     {
          "algorithm": "The new algorithm selects the next node by integrating adaptive thresholding for candidate pruning, hybrid scoring with modified weights for edge cost normalization and MST-based global connectivity, trajectory momentum alignment with enhanced bonuses, and lightweight Monte Carlo-inspired lookahead simulations to dynamically balance exploration and exploitation.}\n\n```python\nimport numpy as np\nfrom heapq import heappush, heappop\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes",
          "code": "import numpy as np\nfrom heapq import heappush, heappop\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    priority_queue = []\n    adaptive_weight = np.random.uniform(1.0, 1.5)  # Adjusted range for adaptive weight\n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.8 * median_distance  # Increased threshold factor\n    \n    for candidate in unvisited_nodes:\n        direct_cost = distance_matrix[current_node][candidate]\n        if direct_cost > threshold_factor:\n            continue  # Prune candidates beyond adaptive threshold\n        look_ahead_cost = lookahead_simulation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        momentum_bonus = 0.6 * (1 - direct_cost / max(distance_matrix[current_node]))  # Enhanced momentum bonus\n        hybrid_score = (adaptive_weight * look_ahead_cost) + (1.0 * mst_remaining) + (0.6 * normalized_cost) - momentum_bonus  # Modified weights\n        heappush(priority_queue, (hybrid_score, candidate))\n    \n    next_node = heappop(priority_queue)[1]\n    return next_node",
          "objective": 5.97927,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Combine short-term decision metrics with long-term structural considerations to guide incremental progress toward an optimal solution.",
                    "Combine short-term, computationally efficient heuristics with long-term, structural evaluations to guide decision-making effectively.",
                    "Combine exploration and exploitation dynamically by adjusting decision weights based on the progress of the search process."
               ],
               "attention_focus": "optimizing established successful strategies and patterns",
               "generation_tendency": "balanced_search",
               "timestamp": 1758183960.110417
          }
     },
     {
          "algorithm": "The new algorithm incrementally selects the next node by prioritizing candidates based on a hybrid scoring function combining normalized edge costs, momentum-based trajectory alignment, MST-based global connectivity, and Monte Carlo-inspired lookahead simulations with adaptive weighting tuned for early exploration and late exploitation.}\n\n```python\nimport numpy as np\nfrom heapq import heappush, heappop\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes",
          "code": "import numpy as np\nfrom heapq import heappush, heappop\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    priority_queue = []\n    adaptive_weight = np.random.uniform(0.6, 1.4)\n    median_distance = np.median(distance_matrix[current_node])\n    \n    for candidate in unvisited_nodes:\n        direct_cost = distance_matrix[current_node][candidate]\n        look_ahead_cost = lookahead_simulation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        momentum_bonus = 0.5 * (1 - direct_cost / max(distance_matrix[current_node]))\n        hybrid_score = (adaptive_weight * look_ahead_cost) + (0.9 * mst_remaining) + (0.3 * normalized_cost) - momentum_bonus\n        heappush(priority_queue, (hybrid_score, candidate))\n    \n    next_node = heappop(priority_queue)[1]\n    return next_node",
          "objective": 5.98521,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Use incremental, greedy decisions to build solutions while preserving global constraints through efficient data structures (e.g., union-find for connectivity tracking).",
                    "Leverage heuristic-guided exploration to efficiently evaluate candidate choices, focusing on a subset of high-potential options to balance computational cost and solution quality.",
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
               ],
               "attention_focus": "experimenting with hybrid strategy combinations",
               "generation_tendency": "balanced_search",
               "timestamp": 1758182841.285204
          }
     },
     {
          "algorithm": "A dynamic hybrid algorithm that balances short-term cost efficiency with long-term structural adaptability through randomized weighting and adaptive exploration-exploitation trade-offs.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def structural_diversity(node):\n        cluster = sorted(unvisited_nodes, key=lambda x: distance_matrix[node][x])[:5]\n        return np.std([distance_matrix[node][n] for n in cluster])\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        total_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            total_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return total_cost + distance_matrix[last][destination_node]\n    \n    def edge_cost_normalization(node):\n        return distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(8, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def structural_diversity(node):\n        cluster = sorted(unvisited_nodes, key=lambda x: distance_matrix[node][x])[:5]\n        return np.std([distance_matrix[node][n] for n in cluster])\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        total_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            total_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return total_cost + distance_matrix[last][destination_node]\n    \n    def edge_cost_normalization(node):\n        return distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(8, len(unvisited_nodes))]\n    scores = {}\n    random_factor = np.random.uniform(0.8, 1.2)  # Introduce randomness to adjust weights dynamically\n    \n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        diversity_score = structural_diversity(candidate)\n        simulation_cost = lookahead_simulation(candidate)\n        normalized_edge_cost = edge_cost_normalization(candidate)\n        scores[candidate] = (\n            0.5 * simulation_cost * random_factor +\n            0.25 * diversity_score / random_factor +\n            0.15 * normalized_edge_cost +\n            0.1 * direct_cost\n        )\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.99158,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Combine short-term decision metrics with long-term structural considerations to guide incremental progress toward an optimal solution.",
                    "Combine short-term, computationally efficient heuristics with long-term, structural evaluations to guide decision-making effectively.",
                    "Combine exploration and exploitation dynamically by adjusting decision weights based on the progress of the search process."
               ],
               "attention_focus": "introducing new randomization or adaptive mechanisms",
               "generation_tendency": "focus_exploration",
               "timestamp": 1758183962.638315
          }
     },
     {
          "algorithm": "",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def simplified_mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted(distance_matrix[i][j] for i in nodes for j in nodes if i < j)\n        return sum(edges[:len(nodes)-1]) if edges else 0\n\n    def simplified_lookahead(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n\n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {}\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        lookahead_cost = simplified_lookahead(candidate)\n        mst_cost_remaining = simplified_mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (\n            0.6 * lookahead_cost +\n            0.4 * mst_cost_remaining +\n            0.3 * normalized_cost\n        )\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.99821,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Combine short-term cost minimization with long-term structural considerations to guide decision-making.",
                    "Combine multiple heuristic strategies to dynamically balance exploration and exploitation during the search process.",
                    "Leverage statistical approximations and lightweight simulations to prioritize decisions that maximize robustness under uncertainty."
               ],
               "attention_focus": "considering completely different algorithmic paradigms",
               "generation_tendency": "balanced_search",
               "timestamp": 1758183651.900966
          }
     },
     {
          "algorithm": "The new algorithm balances short-term efficiency with long-term structural considerations by dynamically adjusting weights for direct costs, lookahead evaluations, and MST-based estimations while incorporating path momentum and clustering effects.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def simplified_mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted(distance_matrix[i][j] for i in nodes for j in nodes if i < j)\n        return sum(edges[:len(nodes)-1]) if edges else 0\n\n    def simplified_lookahead(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n\n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def simplified_mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted(distance_matrix[i][j] for i in nodes for j in nodes if i < j)\n        return sum(edges[:len(nodes)-1]) if edges else 0\n\n    def simplified_lookahead(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n\n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {}\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        lookahead_cost = simplified_lookahead(candidate)\n        mst_cost_remaining = simplified_mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n        path_momentum = np.dot(\n            np.array([distance_matrix[current_node][candidate], distance_matrix[candidate][destination_node]]),\n            np.array([0.7, 0.3])\n        )\n        scores[candidate] = (\n            0.5 * lookahead_cost +\n            0.3 * mst_cost_remaining +\n            0.2 * normalized_cost +\n            0.4 * path_momentum\n        )\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.0049,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Combine short-term decision metrics with long-term structural considerations to guide incremental progress toward an optimal solution.",
                    "Combine short-term, computationally efficient heuristics with long-term, structural evaluations to guide decision-making effectively.",
                    "Combine exploration and exploitation dynamically by adjusting decision weights based on the progress of the search process."
               ],
               "attention_focus": "managing computational complexity and time efficiency",
               "generation_tendency": "balanced_search",
               "timestamp": 1758183940.309673
          }
     },
     {
          "algorithm": "The new algorithm prioritizes local cost efficiency and global structural alignment by dynamically adjusting weights for lookahead simulations, MST-based guidance, and cluster density evaluations while incorporating momentum-based directional preferences.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def compute_mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted(distance_matrix[i][j] for i in nodes for j in nodes if i < j)\n        return sum(edges[:len(nodes)-1]) if edges else 0\n    \n    def simulate_lookahead(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    def evaluate_cluster_affinity(node):\n        avg_distance = np.mean([distance_matrix[node][n] for n in unvisited_nodes])\n        std_distance = np.std([distance_matrix[node][n] for n in unvisited_nodes])\n        return avg_distance / (std_distance + 1e-6)\n    \n    adaptive_weight = np.random.uniform(0.9, 1.3)\n    global_mst_cost = compute_mst_cost(unvisited_nodes + [destination_node])\n    candidate_scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def compute_mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted(distance_matrix[i][j] for i in nodes for j in nodes if i < j)\n        return sum(edges[:len(nodes)-1]) if edges else 0\n    \n    def simulate_lookahead(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    def evaluate_cluster_affinity(node):\n        avg_distance = np.mean([distance_matrix[node][n] for n in unvisited_nodes])\n        std_distance = np.std([distance_matrix[node][n] for n in unvisited_nodes])\n        return avg_distance / (std_distance + 1e-6)\n    \n    adaptive_weight = np.random.uniform(0.9, 1.3)\n    global_mst_cost = compute_mst_cost(unvisited_nodes + [destination_node])\n    candidate_scores = {}\n    \n    for candidate in unvisited_nodes:\n        direct_cost = distance_matrix[current_node][candidate]\n        lookahead_cost = simulate_lookahead(candidate)\n        mst_remaining = compute_mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        cluster_affinity = evaluate_cluster_affinity(candidate)\n        normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n        momentum_factor = np.dot(\n            np.array([distance_matrix[current_node][candidate], 1]),\n            np.array([1, -0.5])\n        )\n        score = (\n            adaptive_weight * lookahead_cost +\n            0.6 * mst_remaining +\n            0.4 * normalized_cost -\n            0.2 * cluster_affinity +\n            0.1 * momentum_factor\n        )\n        candidate_scores[candidate] = score\n    \n    next_node = min(candidate_scores, key=candidate_scores.get)\n    return next_node",
          "objective": 6.01677,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Combine short-term decision metrics with long-term structural considerations to guide incremental progress toward an optimal solution.",
                    "Combine short-term, computationally efficient heuristics with long-term, structural evaluations to guide decision-making effectively.",
                    "Combine exploration and exploitation dynamically by adjusting decision weights based on the progress of the search process."
               ],
               "attention_focus": "managing computational complexity and time efficiency",
               "generation_tendency": "balanced_search",
               "timestamp": 1758183964.2567182
          }
     }
]