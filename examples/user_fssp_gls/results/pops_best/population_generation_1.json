{
     "algorithm": "A hybrid algorithm adaptively perturbs jobs and updates the execution time matrix by combining machine learning-driven job prioritization, dynamic objective weighting, and local search enhancement to escape local optima and minimize makespan.",
     "code": "import numpy as np\n\ndef get_matrix_and_jobs(current_sequence, time_matrix, m, n):\n    def calculate_makespan(sequence, matrix, m):\n        machine_times = [0] * m\n        for job in sequence:\n            machine_times[0] += matrix[job][0]\n            for i in range(1, m):\n                machine_times[i] = max(machine_times[i], machine_times[i-1]) + matrix[job][i]\n        return machine_times[-1]\n\n    # Calculate current makespan\n    current_makespan = calculate_makespan(current_sequence, time_matrix, m)\n\n    # Perturb jobs using a hybrid approach\n    perturb_jobs = []\n    new_matrix = time_matrix.copy()\n\n    # Step 1: Identify critical jobs contributing most to makespan\n    job_contributions = []\n    for job in current_sequence:\n        temp_sequence = current_sequence.copy()\n        temp_sequence.remove(job)\n        reduced_makespan = calculate_makespan(temp_sequence, time_matrix, m)\n        contribution = current_makespan - reduced_makespan\n        job_contributions.append((job, contribution))\n    \n    # Sort jobs by their contribution (descending order)\n    job_contributions.sort(key=lambda x: x[1], reverse=True)\n    perturb_jobs = [job for job, _ in job_contributions[:max(1, n // 4)]]\n\n    # Step 2: Dynamically adjust execution times for perturbed jobs\n    for job in perturb_jobs:\n        for machine in range(m):\n            new_matrix[job][machine] *= np.random.uniform(0.9, 1.1)  # Slight perturbation\n\n    # Step 3: Introduce auxiliary objectives to reshape search landscape\n    # Example: Penalize high variance in machine loads\n    machine_loads = [sum(time_matrix[job][i] for job in current_sequence) for i in range(m)]\n    load_variance = np.var(machine_loads)\n    if load_variance > np.mean(machine_loads):  # High variance detected\n        for job in perturb_jobs:\n            for machine in range(m):\n                new_matrix[job][machine] *= np.random.uniform(0.85, 1.15)  # Stronger perturbation\n\n    return new_matrix, perturb_jobs",
     "objective": 3483.0,
     "other_inf": null,
     "metadata": {
          "operator": "i1",
          "wisdom_tips": [
               "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features",
               "Employ machine learning or pattern recognition to mine deep problem structures and optimal solution patterns then use learned insights to intelligently bias towards promising search regions or constructive choices",
               "Explore objective function engineering by introducing auxiliary or surrogate objectives or by dynamically adjusting weights to reshape the search landscape aiding escape from local optima or guiding diverse exploration"
          ],
          "attention_focus": "improving algorithm robustness across different problem instances",
          "generation_tendency": "balanced_search",
          "timestamp": 1757944831.997516
     }
}