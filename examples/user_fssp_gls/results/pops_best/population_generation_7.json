{
     "algorithm": "```",
     "code": "import numpy as np\n\ndef get_matrix_and_jobs(current_sequence, time_matrix, m, n):\n    def calculate_makespan(sequence, matrix, m):\n        machine_times = [0] * m\n        for job in sequence:\n            machine_times[0] += matrix[job][0]\n            for i in range(1, m):\n                machine_times[i] = max(machine_times[i], machine_times[i-1]) + matrix[job][i]\n        return machine_times[-1]\n\n    # Calculate current makespan\n    current_makespan = calculate_makespan(current_sequence, time_matrix, m)\n\n    # Simplified perturbation strategy\n    perturb_jobs = []\n    new_matrix = time_matrix.copy()\n\n    # Step 1: Identify and select jobs with the highest contribution to makespan\n    job_contributions = [\n        (job, time_matrix[job][0]) for job in current_sequence\n    ]\n    job_contributions.sort(key=lambda x: x[1], reverse=True)\n    perturb_jobs = [job for job, _ in job_contributions[:max(1, n // 4)]]\n\n    # Step 2: Apply uniform perturbation to selected jobs\n    for job in perturb_jobs:\n        for machine in range(m):\n            new_matrix[job][machine] *= np.random.uniform(0.9, 1.1)  # Uniform perturbation\n\n    # Step 3: Simplify auxiliary objective handling\n    machine_loads = [sum(time_matrix[job][i] for job in current_sequence) for i in range(m)]\n    load_variance = np.var(machine_loads)\n    if load_variance > np.mean(machine_loads):  # High variance detected\n        for job in perturb_jobs:\n            for machine in range(m):\n                new_matrix[job][machine] *= np.random.uniform(0.85, 1.15)  # Stronger perturbation\n\n    return new_matrix, perturb_jobs",
     "objective": 3474.66667,
     "other_inf": null,
     "metadata": {
          "operator": "m3",
          "wisdom_tips": [
               "Identify and prioritize critical components that significantly influence the objective function to guide optimization decisions.",
               "Use perturbation strategies that selectively modify problem parameters to explore high-impact changes while preserving solution stability.",
               "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
          ],
          "attention_focus": "experimenting with hybrid strategy combinations",
          "generation_tendency": "focus_exploration",
          "timestamp": 1757951305.0649412
     }
}