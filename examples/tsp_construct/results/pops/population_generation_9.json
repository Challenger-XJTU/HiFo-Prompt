[
     {
          "algorithm": "A hybrid algorithm that combines dynamic candidate pruning, trajectory-aware lookahead simulations, and a scoring mechanism integrating normalized edge costs, structural coherence via MST fragments, and path momentum with probabilistic MCTS-inspired rollouts.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        max_cost = max(distance_matrix[current_node])\n        return 1 - (direct_cost / max_cost)\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = momentum_score(node)\n        return (\n            0.4 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Prune candidates based on normalized edge costs\n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using hybrid scoring\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        max_cost = max(distance_matrix[current_node])\n        return 1 - (direct_cost / max_cost)\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = momentum_score(node)\n        return (\n            0.4 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Prune candidates based on normalized edge costs\n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using hybrid scoring\n    scores = {}\n    for candidate in candidates:\n        scores[candidate] = hybrid_score(candidate)\n    \n    # Select the next node with the lowest hybrid score\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.88828,
          "other_inf": null,
          "metadata": {
               "operator": "e1",
               "wisdom_tips": [
                    "Use normalized metrics and hybrid scoring mechanisms to ensure robustness against varying problem scales and complexities.",
                    "Integrate lookahead-based evaluations to balance exploration and exploitation, ensuring decisions are informed by both immediate costs and future trajectory impacts.",
                    "Use hybrid scoring mechanisms that combine multiple metrics (e.g., normalized costs, structural coherence, and momentum) to dynamically adapt to problem-specific trade-offs."
               ],
               "attention_focus": "experimenting with hybrid strategy combinations",
               "generation_tendency": "balanced_search",
               "timestamp": 1758185290.9559622
          }
     },
     {
          "algorithm": "A hybrid algorithm that balances short-term gains with long-term feasibility by reweighting normalized edge costs, MST coherence, and adaptive momentum with a stronger emphasis on global structure.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def adaptive_momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        avg_cost = np.mean(distance_matrix[current_node])\n        scaled_momentum = 1 - (direct_cost / (avg_cost + 1e-6))\n        return scaled_momentum ** 3  # Cubic to further emphasize high-momentum choices\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = adaptive_momentum_score(node)\n        return (\n            0.4 * look_ahead_cost +\n            0.35 * mst_remaining +\n            0.15 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Dynamically adjust candidate threshold based on unvisited node density\n    median_distance = np.median(distance_matrix[current_node])\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    threshold_factor = (1.5 + 0.5 * density_factor) * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using refined hybrid scoring\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def adaptive_momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        avg_cost = np.mean(distance_matrix[current_node])\n        scaled_momentum = 1 - (direct_cost / (avg_cost + 1e-6))\n        return scaled_momentum ** 3  # Cubic to further emphasize high-momentum choices\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = adaptive_momentum_score(node)\n        return (\n            0.4 * look_ahead_cost +\n            0.35 * mst_remaining +\n            0.15 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Dynamically adjust candidate threshold based on unvisited node density\n    median_distance = np.median(distance_matrix[current_node])\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    threshold_factor = (1.5 + 0.5 * density_factor) * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using refined hybrid scoring\n    scores = {}\n    for candidate in candidates:\n        scores[candidate] = hybrid_score(candidate)\n    \n    # Select the next node with the lowest hybrid score\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.90634,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Use hybrid scoring mechanisms that combine normalized local costs, global structural coherence, and dynamic adaptability to guide decision-making effectively.",
                    "**Evaluate candidates using a greedy heuristic that prioritizes short-term gains while approximating long-term feasibility.**",
                    "Use incremental, greedy decisions to build solutions while preserving global constraints through efficient data structures (e.g., union-find for connectivity tracking)."
               ],
               "attention_focus": "investigating alternative problem decomposition approaches",
               "generation_tendency": "focus_exploration",
               "timestamp": 1758185586.6458108
          }
     },
     {
          "algorithm": "The new algorithm selects the next node by integrating adaptive candidate pruning with structural diversity, lookahead-based evaluations to balance exploration and exploitation, and a hybrid scoring mechanism that incorporates normalized costs, global MST coherence, and trajectory momentum.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        look_ahead_cost = lookahead_evaluation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        momentum_bonus = 0.5 * (1 - direct_cost / max(distance_matrix[current_node]))\n        hybrid_score = (\n            0.4 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost -\n            0.1 * momentum_bonus\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.92681,
          "other_inf": null,
          "metadata": {
               "operator": "e2",
               "wisdom_tips": [
                    "Dynamically balance exploration and exploitation by incorporating structural diversity and lookahead evaluations to guide decision-making while avoiding premature convergence.",
                    "Reduce computational overhead by adaptively pruning candidates based on normalized costs and focusing evaluations on a manageable subset of high-potential options.",
                    "Use heuristic-guided candidate selection to reduce the search space while preserving high-quality solution potential."
               ],
               "attention_focus": "optimizing established successful strategies and patterns",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758184549.645813
          }
     },
     {
          "algorithm": "The new algorithm selects the next node by dynamically balancing structural pruning, lookahead evaluations, and momentum-based scoring with adjusted weights to emphasize exploration while maintaining computational efficiency.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_momentum(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n    \n    def mst_pruning_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_momentum(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n    \n    def mst_pruning_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    scores = {}\n    median_distance = np.median(distance_matrix[current_node])\n    for candidate in unvisited_nodes:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        momentum_score = cluster_momentum(candidate)\n        lookahead_score = lookahead_simulation(candidate)\n        mst_score = mst_pruning_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        hybrid_score = (\n            0.5 * lookahead_score +\n            0.2 * mst_score +\n            0.2 * normalized_cost +\n            0.1 * momentum_score\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.93102,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Integrate adaptive pruning strategies with structural diversity to enhance exploration while maintaining computational efficiency.",
                    "Combine normalized cost metrics with lookahead-based evaluations to dynamically balance short-term gains and long-term solution coherence.",
                    "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations."
               ],
               "attention_focus": "managing computational complexity and time efficiency",
               "generation_tendency": "balanced_search",
               "timestamp": 1758185137.254592
          }
     },
     {
          "algorithm": "The new algorithm prioritizes candidates using a hybrid scoring mechanism that emphasizes long-term feasibility through MST approximation, balances momentum-based trajectory alignment, and leverages Monte Carlo-inspired statistical sampling for dynamic adaptability.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    def monte_carlo_simulation(node, simulations=50):\n        total_cost = 0\n        for _ in range(simulations):\n            remaining_nodes = list(unvisited_nodes)\n            remaining_nodes.remove(node)\n            path_cost = distance_matrix[current_node][node]\n            last_node = node\n            while remaining_nodes:\n                next_step = np.random.choice(remaining_nodes)\n                path_cost += distance_matrix[last_node][next_step]\n                last_node = next_step\n                remaining_nodes.remove(next_step)\n            path_cost += distance_matrix[last_node][destination_node]\n            total_cost += path_cost\n        return total_cost / simulations\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 2.0 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    def monte_carlo_simulation(node, simulations=50):\n        total_cost = 0\n        for _ in range(simulations):\n            remaining_nodes = list(unvisited_nodes)\n            remaining_nodes.remove(node)\n            path_cost = distance_matrix[current_node][node]\n            last_node = node\n            while remaining_nodes:\n                next_step = np.random.choice(remaining_nodes)\n                path_cost += distance_matrix[last_node][next_step]\n                last_node = next_step\n                remaining_nodes.remove(next_step)\n            path_cost += distance_matrix[last_node][destination_node]\n            total_cost += path_cost\n        return total_cost / simulations\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 2.0 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        look_ahead_cost = lookahead_evaluation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        mc_simulated_cost = monte_carlo_simulation(candidate)\n        hybrid_score = (\n            0.4 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost +\n            0.1 * mc_simulated_cost\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.94077,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Use hybrid scoring mechanisms that combine normalized local costs, global structural coherence, and dynamic adaptability to guide decision-making effectively.",
                    "**Evaluate candidates using a greedy heuristic that prioritizes short-term gains while approximating long-term feasibility.**",
                    "Use incremental, greedy decisions to build solutions while preserving global constraints through efficient data structures (e.g., union-find for connectivity tracking)."
               ],
               "attention_focus": "considering completely different algorithmic paradigms",
               "generation_tendency": "balanced_search",
               "timestamp": 1758185602.911247
          }
     },
     {
          "algorithm": "A refined hybrid algorithm that optimizes precision by dynamically adjusting candidate thresholds, incorporating adaptive momentum scaling, and leveraging MST-based global coherence to guide greedy decision-making.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def adaptive_momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        avg_cost = np.mean(distance_matrix[current_node])\n        scaled_momentum = 1 - (direct_cost / (avg_cost + 1e-6))\n        return scaled_momentum ** 2  # Squared to emphasize high-momentum choices\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = adaptive_momentum_score(node)\n        return (\n            0.35 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.25 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Dynamically adjust candidate threshold based on unvisited node density\n    median_distance = np.median(distance_matrix[current_node])\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    threshold_factor = (1.2 + 0.3 * density_factor) * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using refined hybrid scoring\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def adaptive_momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        avg_cost = np.mean(distance_matrix[current_node])\n        scaled_momentum = 1 - (direct_cost / (avg_cost + 1e-6))\n        return scaled_momentum ** 2  # Squared to emphasize high-momentum choices\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = adaptive_momentum_score(node)\n        return (\n            0.35 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.25 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Dynamically adjust candidate threshold based on unvisited node density\n    median_distance = np.median(distance_matrix[current_node])\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    threshold_factor = (1.2 + 0.3 * density_factor) * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using refined hybrid scoring\n    scores = {}\n    for candidate in candidates:\n        scores[candidate] = hybrid_score(candidate)\n    \n    # Select the next node with the lowest hybrid score\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.94375,
          "other_inf": null,
          "metadata": {
               "operator": "m1",
               "wisdom_tips": [
                    "Use hybrid scoring mechanisms that combine normalized local costs, global structural coherence, and dynamic adaptability to guide decision-making effectively.",
                    "**Evaluate candidates using a greedy heuristic that prioritizes short-term gains while approximating long-term feasibility.**",
                    "Use incremental, greedy decisions to build solutions while preserving global constraints through efficient data structures (e.g., union-find for connectivity tracking)."
               ],
               "attention_focus": "improving precision of existing heuristics and rules",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758185413.462416
          }
     },
     {
          "algorithm": "node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        look_ahead_cost = lookahead_evaluation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        hybrid_score = (\n            0.5 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.95081,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Integrate adaptive pruning strategies with structural diversity to enhance exploration while maintaining computational efficiency.",
                    "Combine normalized cost metrics with lookahead-based evaluations to dynamically balance short-term gains and long-term solution coherence.",
                    "Use normalized metrics and hybrid scoring mechanisms to ensure robustness against varying problem scales and complexities."
               ],
               "attention_focus": "fine-tuning critical algorithm parameters and thresholds",
               "generation_tendency": "balanced_search",
               "timestamp": 1758185183.04735
          }
     },
     {
          "algorithm": "The new algorithm dynamically prioritizes edge costs, lookahead-based global coherence, and structural diversity by adaptively weighting normalized costs, cluster quality, and long-term path feasibility while emphasizing exploration-exploitation balance through adjusted score function parameters.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_score(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n\n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n\n    def beam_search_candidates():\n        candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n        beams = []\n        for candidate in candidates:\n            direct_cost = distance_matrix[current_node][candidate]\n            lookahead_cost = lookahead_evaluation(candidate)\n            cluster_quality = cluster_score(candidate)\n            normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n            score = (\n                0.4 * lookahead_cost +\n                0.35 * cluster_quality +\n                0.15 * normalized_cost +\n                0.1 * direct_cost\n            )\n            beams.append((score, candidate))\n        beams.sort(key=lambda x: x[0])\n        return [node for _, node in beams[:min(3, len(beams))]]\n\n    candidate_beam = beam_search_candidates()\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_score(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n\n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n\n    def beam_search_candidates():\n        candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n        beams = []\n        for candidate in candidates:\n            direct_cost = distance_matrix[current_node][candidate]\n            lookahead_cost = lookahead_evaluation(candidate)\n            cluster_quality = cluster_score(candidate)\n            normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n            score = (\n                0.4 * lookahead_cost +\n                0.35 * cluster_quality +\n                0.15 * normalized_cost +\n                0.1 * direct_cost\n            )\n            beams.append((score, candidate))\n        beams.sort(key=lambda x: x[0])\n        return [node for _, node in beams[:min(3, len(beams))]]\n\n    candidate_beam = beam_search_candidates()\n    scores = {}\n    for candidate in candidate_beam:\n        direct_cost = distance_matrix[current_node][candidate]\n        lookahead_cost = lookahead_evaluation(candidate)\n        cluster_quality = cluster_score(candidate)\n        normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (\n            0.5 * lookahead_cost +\n            0.25 * cluster_quality +\n            0.15 * normalized_cost +\n            0.1 * direct_cost\n        )\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.95751,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Integrate adaptive pruning strategies with structural diversity to enhance exploration while maintaining computational efficiency.",
                    "Combine normalized cost metrics with lookahead-based evaluations to dynamically balance short-term gains and long-term solution coherence.",
                    "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations."
               ],
               "attention_focus": "considering long-term impact of current decisions",
               "generation_tendency": "balanced_search",
               "timestamp": 1758185159.838847
          }
     }
]