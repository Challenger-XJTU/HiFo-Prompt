[
     {
          "algorithm": "node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {}\n    adaptive_weight = np.random.uniform(0.7, 1.3)  # Reduced range for stability\n    for candidate in candidates:\n        look_ahead_cost = evaluate_candidate(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = distance_matrix[current_node][candidate] / (np.median(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (adaptive_weight * look_ahead_cost) + (0.6 * mst_remaining) + (0.4 * normalized_cost)\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.07493,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Combine structural insights (e.g., MST-based cost modeling) with greedy heuristics to guide decision-making while preserving global solution quality.",
                    "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations.",
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
               ],
               "attention_focus": "exploring novel solution construction methodologies",
               "generation_tendency": "balanced_search",
               "timestamp": 1758182497.993067
          }
     },
     {
          "algorithm": "node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {}\n    adaptive_weight = np.random.uniform(0.7, 1.3)  # Fine-tuned adaptive randomization range\n    for candidate in candidates:\n        look_ahead_cost = evaluate_candidate(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = distance_matrix[current_node][candidate] / (np.median(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (adaptive_weight * look_ahead_cost) + (0.6 * mst_remaining) + (0.4 * normalized_cost)\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.07964,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Combine structural insights (e.g., MST-based cost modeling) with greedy heuristics to guide decision-making while preserving global solution quality.",
                    "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations.",
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
               ],
               "attention_focus": "fine-tuning critical algorithm parameters and thresholds",
               "generation_tendency": "balanced_search",
               "timestamp": 1758182533.9477592
          }
     },
     {
          "algorithm": "node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {}\n    adaptive_weight = np.random.uniform(0.7, 1.3)  # Reduced randomness range for stability\n    for candidate in candidates:\n        look_ahead_cost = evaluate_candidate(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = distance_matrix[current_node][candidate] / (np.median(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (adaptive_weight * look_ahead_cost) + (0.6 * mst_remaining) + (0.4 * normalized_cost)\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.10535,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Combine structural insights (e.g., MST-based cost modeling) with greedy heuristics to guide decision-making while preserving global solution quality.",
                    "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations.",
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
               ],
               "attention_focus": "investigating alternative problem decomposition approaches",
               "generation_tendency": "balanced_search",
               "timestamp": 1758182523.211709
          }
     },
     {
          "algorithm": "Design a hybrid algorithm that integrates adaptive randomization and dynamic weighting of MST-based, look-ahead, and trajectory-based costs while leveraging incremental updates for efficient candidate evaluation.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {}\n    adaptive_weight = np.random.uniform(0.5, 1.5)  # Introduce adaptive randomization\n    for candidate in candidates:\n        look_ahead_cost = evaluate_candidate(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = distance_matrix[current_node][candidate] / (np.median(distance_matrix[current_node]) + 1e-6)\n        momentum_cost = np.linalg.norm(np.array(distance_matrix[current_node][candidate]) - np.mean(distance_matrix[current_node]))\n        scores[candidate] = (adaptive_weight * look_ahead_cost) + (0.7 * mst_remaining) + (0.3 * normalized_cost) + (0.2 * momentum_cost)\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.10586,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Leverage incremental updates and path compression to efficiently manage and query connected components in dynamic structures.",
                    "Use heuristic-guided candidate selection to reduce the search space while preserving high-quality solution potential.",
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
               ],
               "attention_focus": "introducing new randomization or adaptive mechanisms",
               "generation_tendency": "focus_exploration",
               "timestamp": 1758182459.560787
          }
     },
     {
          "algorithm": "node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {}\n    for candidate in candidates:\n        look_ahead_cost = evaluate_candidate(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = distance_matrix[current_node][candidate] / (np.mean(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = look_ahead_cost + mst_remaining + normalized_cost\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.18575,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Combine exploration and exploitation dynamically by adjusting decision weights based on the progress of the search process.",
                    "Leverage hybrid strategies that integrate structural insights, such as MST approximations and clustering, with statistical evaluations to robustly guide solution space navigation.",
                    "Combine exploration and exploitation dynamically by integrating global structural insights (e.g., MST approximations) with local decision metrics (e.g., edge cost normalization) to guide the search process effectively."
               ],
               "attention_focus": "balancing local optimality with global search strategies",
               "generation_tendency": "balanced_search",
               "timestamp": 1758182104.288021
          }
     },
     {
          "algorithm": "",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {}\n    for candidate in candidates:\n        look_ahead_cost = evaluate_candidate(candidate)\n        normalized_cost = (distance_matrix[current_node][candidate] / (np.std(distance_matrix[current_node]) + 1e-6)) ** 0.5\n        scores[candidate] = look_ahead_cost + 1.5 * normalized_cost\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.20628,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Combine structural insights (e.g., MST-based cost modeling) with greedy heuristics to guide decision-making while preserving global solution quality.",
                    "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations.",
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
               ],
               "attention_focus": "introducing new randomization or adaptive mechanisms",
               "generation_tendency": "focus_exploration",
               "timestamp": 1758182522.1840189
          }
     },
     {
          "algorithm": "",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {}\n    for candidate in candidates:\n        look_ahead_cost = evaluate_candidate(candidate)\n        direct_cost = distance_matrix[current_node][candidate]\n        heuristic_bonus = 0.5 * distance_matrix[candidate][destination_node]\n        random_factor = np.random.uniform(0.9, 1.1)  # Introduce mild randomization\n        scores[candidate] = look_ahead_cost + direct_cost - heuristic_bonus * random_factor\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.21651,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Combine structural insights (e.g., MST-based cost modeling) with greedy heuristics to guide decision-making while preserving global solution quality.",
                    "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations.",
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
               ],
               "attention_focus": "introducing new randomization or adaptive mechanisms",
               "generation_tendency": "focus_exploration",
               "timestamp": 1758182519.1921642
          }
     },
     {
          "algorithm": "The new algorithm selects the next node by balancing local edge costs, global MST-based cost estimation, and path momentum through a modified scoring function emphasizing normalized look-ahead impact and reduced beam width diversity.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {}\n    for candidate in candidates:\n        look_ahead_cost = evaluate_candidate(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = (distance_matrix[current_node][candidate] / (np.std(distance_matrix[current_node]) + 1e-6)) ** 0.5\n        scores[candidate] = 1.5 * look_ahead_cost + 0.75 * mst_remaining + 2.0 * normalized_cost\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.22526,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Leverage incremental updates and path compression to efficiently manage and query connected components in dynamic structures.",
                    "Use heuristic-guided candidate selection to reduce the search space while preserving high-quality solution potential.",
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
               ],
               "attention_focus": "managing computational complexity and time efficiency",
               "generation_tendency": "balanced_search",
               "timestamp": 1758182443.770977
          }
     }
]