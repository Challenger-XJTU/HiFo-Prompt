[
     {
          "algorithm": "The new algorithm incrementally selects the next node by prioritizing candidates based on a hybrid scoring function combining normalized edge costs, momentum-based trajectory alignment, MST-based global connectivity, and Monte Carlo-inspired lookahead simulations with adaptive weighting tuned for early exploration and late exploitation.}\n\n```python\nimport numpy as np\nfrom heapq import heappush, heappop\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes",
          "code": "import numpy as np\nfrom heapq import heappush, heappop\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    priority_queue = []\n    adaptive_weight = np.random.uniform(0.6, 1.4)\n    median_distance = np.median(distance_matrix[current_node])\n    \n    for candidate in unvisited_nodes:\n        direct_cost = distance_matrix[current_node][candidate]\n        look_ahead_cost = lookahead_simulation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        momentum_bonus = 0.5 * (1 - direct_cost / max(distance_matrix[current_node]))\n        hybrid_score = (adaptive_weight * look_ahead_cost) + (0.9 * mst_remaining) + (0.3 * normalized_cost) - momentum_bonus\n        heappush(priority_queue, (hybrid_score, candidate))\n    \n    next_node = heappop(priority_queue)[1]\n    return next_node",
          "objective": 5.98521,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Use incremental, greedy decisions to build solutions while preserving global constraints through efficient data structures (e.g., union-find for connectivity tracking).",
                    "Leverage heuristic-guided exploration to efficiently evaluate candidate choices, focusing on a subset of high-potential options to balance computational cost and solution quality.",
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
               ],
               "attention_focus": "experimenting with hybrid strategy combinations",
               "generation_tendency": "balanced_search",
               "timestamp": 1758182841.285204
          }
     },
     {
          "algorithm": "node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {}\n    adaptive_weight = np.random.uniform(0.7, 1.3)  # Reduced range for stability\n    for candidate in candidates:\n        look_ahead_cost = evaluate_candidate(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = distance_matrix[current_node][candidate] / (np.median(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (adaptive_weight * look_ahead_cost) + (0.6 * mst_remaining) + (0.4 * normalized_cost)\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.07493,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Combine structural insights (e.g., MST-based cost modeling) with greedy heuristics to guide decision-making while preserving global solution quality.",
                    "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations.",
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
               ],
               "attention_focus": "exploring novel solution construction methodologies",
               "generation_tendency": "balanced_search",
               "timestamp": 1758182497.993067
          }
     },
     {
          "algorithm": "node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {}\n    adaptive_weight = np.random.uniform(0.7, 1.3)  # Fine-tuned adaptive randomization range\n    for candidate in candidates:\n        look_ahead_cost = evaluate_candidate(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = distance_matrix[current_node][candidate] / (np.median(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (adaptive_weight * look_ahead_cost) + (0.6 * mst_remaining) + (0.4 * normalized_cost)\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.07964,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Combine structural insights (e.g., MST-based cost modeling) with greedy heuristics to guide decision-making while preserving global solution quality.",
                    "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations.",
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
               ],
               "attention_focus": "fine-tuning critical algorithm parameters and thresholds",
               "generation_tendency": "balanced_search",
               "timestamp": 1758182533.9477592
          }
     },
     {
          "algorithm": "candidate: evaluate_candidate(candidate) for candidate in candidates",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        total_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            total_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        total_cost += distance_matrix[last_node][destination_node]\n        return total_cost\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(3, len(unvisited_nodes))]\n    scores = {candidate: evaluate_candidate(candidate) for candidate in candidates}\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.08232,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Use incremental, greedy decisions to build solutions while preserving global constraints through efficient data structures (e.g., union-find for connectivity tracking).",
                    "Leverage heuristic-guided exploration to efficiently evaluate candidate choices, focusing on a subset of high-potential options to balance computational cost and solution quality.",
                    "Use incremental greedy decisions to construct solutions while ensuring global constraints are preserved."
               ],
               "attention_focus": "considering completely different algorithmic paradigms",
               "generation_tendency": "focus_exploration",
               "timestamp": 1758182919.51128
          }
     },
     {
          "algorithm": "The new algorithm incrementally updates a dynamic priority queue of candidate nodes based on hybrid cost metrics, including MST-based global costs, look-ahead simulations, and trajectory momentum, while adaptively weighting these factors to balance exploration and exploitation.}\n\n```python\nimport numpy as np\nfrom heapq import heappush, heappop\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes",
          "code": "import numpy as np\nfrom heapq import heappush, heappop\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    priority_queue = []\n    adaptive_weight = np.random.uniform(0.8, 1.2)\n    median_distance = np.median(distance_matrix[current_node])\n    \n    for candidate in unvisited_nodes:\n        direct_cost = distance_matrix[current_node][candidate]\n        look_ahead_cost = lookahead_simulation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        momentum_bonus = 0.3 * (1 - direct_cost / max(distance_matrix[current_node]))\n        hybrid_score = (adaptive_weight * look_ahead_cost) + (0.7 * mst_remaining) + (0.5 * normalized_cost) - momentum_bonus\n        heappush(priority_queue, (hybrid_score, candidate))\n    \n    next_node = heappop(priority_queue)[1]\n    return next_node",
          "objective": 6.08343,
          "other_inf": null,
          "metadata": {
               "operator": "e2",
               "wisdom_tips": [
                    "Integrate incremental updates and dynamic weighting to efficiently evaluate candidate solutions while preserving adaptability to changing problem constraints.",
                    "Leverage hybrid strategies that combine complementary cost metrics (e.g., MST-based, look-ahead, trajectory-based) to balance exploration and exploitation in decision-making.",
                    "**Leverage incremental updates to maintain consistency and reduce redundant computations in dynamic structures.**"
               ],
               "attention_focus": "optimizing established successful strategies and patterns",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758182684.6730828
          }
     },
     {
          "algorithm": "The algorithm selects the next node by dynamically balancing MST-based global cost modeling, adaptive lookahead simulations, and path momentum while incorporating randomized thresholds to balance exploration and exploitation.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {}\n    adaptive_weight = np.random.uniform(0.8, 1.2)\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        look_ahead_cost = lookahead_simulation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n        momentum_bonus = 0.3 * (1 - distance_matrix[current_node][candidate] / max(distance_matrix[current_node]))\n        scores[candidate] = (adaptive_weight * look_ahead_cost) + (0.7 * mst_remaining) + (0.5 * normalized_cost) - momentum_bonus\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.0873,
          "other_inf": null,
          "metadata": {
               "operator": "e1",
               "wisdom_tips": [
                    "Combine structural insights (e.g., MST-based cost modeling) with greedy heuristics to guide decision-making while preserving global solution quality.",
                    "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations.",
                    "Integrate incremental updates and dynamic weighting to efficiently evaluate candidate solutions while preserving adaptability to changing problem constraints."
               ],
               "attention_focus": "fine-tuning critical algorithm parameters and thresholds",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758182604.1129742
          }
     },
     {
          "algorithm": "A new algorithm that adaptively balances look-ahead evaluation, normalized edge costs, and MST-based global guidance using tuned scoring weights to select the next node.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {}\n    adaptive_weight = np.random.uniform(0.8, 1.2)  # Slightly adjusted randomness range for stability\n    for candidate in candidates:\n        look_ahead_cost = evaluate_candidate(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = distance_matrix[current_node][candidate] / (np.mean(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (adaptive_weight * look_ahead_cost) + (0.7 * mst_remaining) + (0.3 * normalized_cost)\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.08926,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Use incremental, greedy decisions to build solutions while preserving global constraints through efficient data structures (e.g., union-find for connectivity tracking).",
                    "Leverage heuristic-guided exploration to efficiently evaluate candidate choices, focusing on a subset of high-potential options to balance computational cost and solution quality.",
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
               ],
               "attention_focus": "refining core evaluation and scoring functions",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758182814.749171
          }
     },
     {
          "algorithm": "The algorithm incrementally evaluates candidate nodes using a hybrid scoring function that balances greedy nearest-neighbor selection, minimum spanning tree approximation, and adaptive randomization, while dynamically adjusting weights based on search progress.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def evaluate_candidate(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {}\n    adaptive_weight = np.random.uniform(0.8, 1.2)  # Fine-tuned adaptive randomization range\n    search_progress = 1 - (len(unvisited_nodes) / len(distance_matrix))  # Dynamic adjustment based on search stage\n    \n    for candidate in candidates:\n        look_ahead_cost = evaluate_candidate(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = distance_matrix[current_node][candidate] / (np.median(distance_matrix[current_node]) + 1e-6)\n        momentum_factor = np.exp(-search_progress)  # Decreasing emphasis on momentum as search progresses\n        scores[candidate] = (\n            (adaptive_weight * look_ahead_cost) +\n            (0.5 * mst_remaining) +\n            (0.3 * normalized_cost) +\n            (momentum_factor * distance_matrix[current_node][candidate])\n        )\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 6.09684,
          "other_inf": null,
          "metadata": {
               "operator": "m1",
               "wisdom_tips": [
                    "**Leverage incremental updates to maintain consistency and reduce redundant computations in dynamic structures.**",
                    "**Evaluate candidates using a greedy heuristic that prioritizes short-term gains while approximating long-term feasibility.**",
                    "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
               ],
               "attention_focus": "fine-tuning critical algorithm parameters and thresholds",
               "generation_tendency": "balanced_search",
               "timestamp": 1758182770.788019
          }
     }
]