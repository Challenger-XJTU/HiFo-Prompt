[
     {
          "algorithm": "A hybrid algorithm that combines dynamic candidate pruning, trajectory-aware lookahead simulations, and a scoring mechanism integrating normalized edge costs, structural coherence via MST fragments, and path momentum with probabilistic MCTS-inspired rollouts.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        max_cost = max(distance_matrix[current_node])\n        return 1 - (direct_cost / max_cost)\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = momentum_score(node)\n        return (\n            0.4 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Prune candidates based on normalized edge costs\n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using hybrid scoring\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        max_cost = max(distance_matrix[current_node])\n        return 1 - (direct_cost / max_cost)\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = momentum_score(node)\n        return (\n            0.4 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Prune candidates based on normalized edge costs\n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using hybrid scoring\n    scores = {}\n    for candidate in candidates:\n        scores[candidate] = hybrid_score(candidate)\n    \n    # Select the next node with the lowest hybrid score\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.88828,
          "other_inf": null,
          "metadata": {
               "operator": "e1",
               "wisdom_tips": [
                    "Use normalized metrics and hybrid scoring mechanisms to ensure robustness against varying problem scales and complexities.",
                    "Integrate lookahead-based evaluations to balance exploration and exploitation, ensuring decisions are informed by both immediate costs and future trajectory impacts.",
                    "Use hybrid scoring mechanisms that combine multiple metrics (e.g., normalized costs, structural coherence, and momentum) to dynamically adapt to problem-specific trade-offs."
               ],
               "attention_focus": "experimenting with hybrid strategy combinations",
               "generation_tendency": "balanced_search",
               "timestamp": 1758185290.9559622
          }
     },
     {
          "algorithm": "The new algorithm integrates adaptive candidate pruning, hybrid lookahead-MST scoring, and dynamic momentum adjustment to balance local efficiency and global coherence while optimizing selection thresholds based on instance-specific metrics.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.0 + 0.2 * (len(unvisited_nodes) / len(distance_matrix))\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor * median_distance]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.0 + 0.2 * (len(unvisited_nodes) / len(distance_matrix))\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor * median_distance]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        look_ahead_cost = lookahead_evaluation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        momentum_bonus = 0.5 * (1 - direct_cost / max(distance_matrix[current_node]))\n        hybrid_score = (\n            (0.4 - 0.05 * density_factor) * look_ahead_cost +\n            (0.35 + 0.05 * density_factor) * mst_remaining +\n            0.2 * normalized_cost -\n            (0.05 + 0.02 * density_factor) * momentum_bonus\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.89859,
          "other_inf": null,
          "metadata": {
               "operator": "m1",
               "wisdom_tips": [
                    "Combine short-term decision-making with long-term structural considerations to ensure both immediate efficiency and global coherence.",
                    "Dynamically adapt selection criteria based on instance-specific metrics to enhance robustness and scalability across varying problem complexities.",
                    "Dynamically adjust candidate selection thresholds based on instance-specific characteristics to enhance exploration efficiency."
               ],
               "attention_focus": "optimizing established successful strategies and patterns",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758186834.234134
          }
     },
     {
          "algorithm": "A new algorithm that dynamically integrates adaptive neighborhood clustering, lookahead path evaluation, and momentum-guided trajectory alignment with a global coherence penalty to optimize both local moves and the overall tour structure.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def adaptive_neighborhood(node, density_factor=1.2):\n        median_distance = np.median(distance_matrix[node])\n        threshold = density_factor * median_distance\n        return [n for n in unvisited_nodes if distance_matrix[node][n] <= threshold]\n    \n    def lookahead_path_quality(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def momentum_guidance(node):\n        direct_cost = distance_matrix[current_node][node]\n        avg_cost = np.mean(distance_matrix[current_node])\n        scaled_momentum = 1 - (direct_cost / (avg_cost + 1e-6))\n        return scaled_momentum ** 2\n    \n    def global_coherence_penalty(nodes):\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    candidates = adaptive_neighborhood(current_node)\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def adaptive_neighborhood(node, density_factor=1.2):\n        median_distance = np.median(distance_matrix[node])\n        threshold = density_factor * median_distance\n        return [n for n in unvisited_nodes if distance_matrix[node][n] <= threshold]\n    \n    def lookahead_path_quality(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def momentum_guidance(node):\n        direct_cost = distance_matrix[current_node][node]\n        avg_cost = np.mean(distance_matrix[current_node])\n        scaled_momentum = 1 - (direct_cost / (avg_cost + 1e-6))\n        return scaled_momentum ** 2\n    \n    def global_coherence_penalty(nodes):\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    candidates = adaptive_neighborhood(current_node)\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    for candidate in candidates:\n        normalized_cost = distance_matrix[current_node][candidate] / (np.median(distance_matrix[current_node]) + 1e-6)\n        lookahead_score = lookahead_path_quality(candidate)\n        momentum_score = momentum_guidance(candidate)\n        coherence_penalty = global_coherence_penalty([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        hybrid_score = (\n            0.45 * lookahead_score +\n            0.3 * coherence_penalty +\n            0.15 * normalized_cost -\n            0.1 * momentum_score\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.90615,
          "other_inf": null,
          "metadata": {
               "operator": "e2",
               "wisdom_tips": [
                    "Combine short-term decision-making with long-term structural considerations to ensure both immediate efficiency and global coherence.",
                    "Dynamically adapt selection criteria based on instance-specific metrics to enhance robustness and scalability across varying problem complexities.",
                    "Dynamically adjust candidate selection thresholds based on instance-specific characteristics to enhance exploration efficiency."
               ],
               "attention_focus": "improving precision of existing heuristics and rules",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758186729.692379
          }
     },
     {
          "algorithm": "A hybrid algorithm that balances short-term gains with long-term feasibility by reweighting normalized edge costs, MST coherence, and adaptive momentum with a stronger emphasis on global structure.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def adaptive_momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        avg_cost = np.mean(distance_matrix[current_node])\n        scaled_momentum = 1 - (direct_cost / (avg_cost + 1e-6))\n        return scaled_momentum ** 3  # Cubic to further emphasize high-momentum choices\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = adaptive_momentum_score(node)\n        return (\n            0.4 * look_ahead_cost +\n            0.35 * mst_remaining +\n            0.15 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Dynamically adjust candidate threshold based on unvisited node density\n    median_distance = np.median(distance_matrix[current_node])\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    threshold_factor = (1.5 + 0.5 * density_factor) * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using refined hybrid scoring\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def adaptive_momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        avg_cost = np.mean(distance_matrix[current_node])\n        scaled_momentum = 1 - (direct_cost / (avg_cost + 1e-6))\n        return scaled_momentum ** 3  # Cubic to further emphasize high-momentum choices\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = adaptive_momentum_score(node)\n        return (\n            0.4 * look_ahead_cost +\n            0.35 * mst_remaining +\n            0.15 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Dynamically adjust candidate threshold based on unvisited node density\n    median_distance = np.median(distance_matrix[current_node])\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    threshold_factor = (1.5 + 0.5 * density_factor) * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using refined hybrid scoring\n    scores = {}\n    for candidate in candidates:\n        scores[candidate] = hybrid_score(candidate)\n    \n    # Select the next node with the lowest hybrid score\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.90634,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Use hybrid scoring mechanisms that combine normalized local costs, global structural coherence, and dynamic adaptability to guide decision-making effectively.",
                    "**Evaluate candidates using a greedy heuristic that prioritizes short-term gains while approximating long-term feasibility.**",
                    "Use incremental, greedy decisions to build solutions while preserving global constraints through efficient data structures (e.g., union-find for connectivity tracking)."
               ],
               "attention_focus": "investigating alternative problem decomposition approaches",
               "generation_tendency": "focus_exploration",
               "timestamp": 1758185586.6458108
          }
     },
     {
          "algorithm": "The new algorithm integrates adaptive momentum-weighted selection, density-aware lookahead pruning, and MST-guided global coherence optimization to balance exploration and exploitation dynamically.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 - 0.3 * (len(unvisited_nodes) / len(distance_matrix))\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor * median_distance]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 - 0.3 * (len(unvisited_nodes) / len(distance_matrix))\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor * median_distance]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        look_ahead_cost = lookahead_evaluation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        momentum_bonus = 0.8 * (1 - direct_cost / max(distance_matrix[current_node]))\n        hybrid_score = (\n            (0.5 - 0.1 * density_factor) * look_ahead_cost +\n            (0.25 + 0.1 * density_factor) * mst_remaining +\n            0.15 * normalized_cost -\n            (0.1 + 0.05 * density_factor) * momentum_bonus\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.91018,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Combine short-term decision-making with long-term structural considerations to ensure both immediate efficiency and global coherence.",
                    "Dynamically adapt selection criteria based on instance-specific metrics to enhance robustness and scalability across varying problem complexities.",
                    "Dynamically adjust candidate selection thresholds based on instance-specific characteristics to enhance exploration efficiency."
               ],
               "attention_focus": "experimenting with hybrid strategy combinations",
               "generation_tendency": "focus_exploration",
               "timestamp": 1758187306.862628
          }
     },
     {
          "algorithm": "A hybrid algorithm that balances immediate edge costs with long-term path coherence by dynamically adjusting scoring weights and candidate thresholds based on instance-specific metrics.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        max_cost = max(distance_matrix[current_node])\n        return 1 - (direct_cost / max_cost)\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = momentum_score(node)\n        return (\n            0.3 * look_ahead_cost +\n            0.4 * mst_remaining +\n            0.15 * normalized_cost -\n            0.15 * momentum\n        )\n    \n    # Prune candidates based on normalized edge costs\n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 2.0 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using hybrid scoring\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        max_cost = max(distance_matrix[current_node])\n        return 1 - (direct_cost / max_cost)\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = momentum_score(node)\n        return (\n            0.3 * look_ahead_cost +\n            0.4 * mst_remaining +\n            0.15 * normalized_cost -\n            0.15 * momentum\n        )\n    \n    # Prune candidates based on normalized edge costs\n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 2.0 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using hybrid scoring\n    scores = {}\n    for candidate in candidates:\n        scores[candidate] = hybrid_score(candidate)\n    \n    # Select the next node with the lowest hybrid score\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.9108,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Combine short-term decision-making with long-term structural considerations to ensure both immediate efficiency and global coherence.",
                    "Dynamically adapt selection criteria based on instance-specific metrics to enhance robustness and scalability across varying problem complexities.",
                    "Dynamically adjust candidate selection thresholds based on instance-specific characteristics to enhance exploration efficiency."
               ],
               "attention_focus": "improving algorithm robustness across different problem instances",
               "generation_tendency": "balanced_search",
               "timestamp": 1758186559.9659069
          }
     },
     {
          "algorithm": "A novel algorithm that integrates adaptive cluster-aware pruning, trajectory-guided lookahead simulations, and a hybrid scoring mechanism combining normalized edge costs, MST-based structural alignment, and probabilistic beam search-like path diversification.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def cluster_affinity_score(node):\n        avg_cluster_distance = np.mean([distance_matrix[node][n] for n in unvisited_nodes])\n        global_avg_distance = np.mean(distance_matrix[node])\n        return 1 - (avg_cluster_distance / (global_avg_distance + 1e-6))\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        cluster_affinity = cluster_affinity_score(node)\n        return (\n            0.35 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost +\n            0.15 * cluster_affinity\n        )\n    \n    # Adaptive candidate pruning based on instance-specific density and clustering\n    median_distance = np.median(distance_matrix[current_node])\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    threshold_factor = (1.2 + 0.8 * density_factor) * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Beam search-inspired path diversification\n    beam_width = max(3, int(np.sqrt(len(unvisited_nodes))))\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def cluster_affinity_score(node):\n        avg_cluster_distance = np.mean([distance_matrix[node][n] for n in unvisited_nodes])\n        global_avg_distance = np.mean(distance_matrix[node])\n        return 1 - (avg_cluster_distance / (global_avg_distance + 1e-6))\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        cluster_affinity = cluster_affinity_score(node)\n        return (\n            0.35 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost +\n            0.15 * cluster_affinity\n        )\n    \n    # Adaptive candidate pruning based on instance-specific density and clustering\n    median_distance = np.median(distance_matrix[current_node])\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    threshold_factor = (1.2 + 0.8 * density_factor) * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Beam search-inspired path diversification\n    beam_width = max(3, int(np.sqrt(len(unvisited_nodes))))\n    scores = {}\n    for candidate in candidates:\n        scores[candidate] = hybrid_score(candidate)\n    top_candidates = sorted(scores.keys(), key=lambda x: scores[x])[:beam_width]\n    \n    # Select the next node with the lowest hybrid score among top candidates\n    next_node = min(top_candidates, key=lambda x: scores[x])\n    return next_node",
          "objective": 5.91541,
          "other_inf": null,
          "metadata": {
               "operator": "e1",
               "wisdom_tips": [
                    "Combine short-term decision-making with long-term structural considerations to ensure both immediate efficiency and global coherence.",
                    "Dynamically adapt selection criteria based on instance-specific metrics to enhance robustness and scalability across varying problem complexities.",
                    "Dynamically adjust candidate selection thresholds based on instance-specific characteristics to enhance exploration efficiency."
               ],
               "attention_focus": "exploring novel solution construction methodologies",
               "generation_tendency": "balanced_search",
               "timestamp": 1758187044.088001
          }
     },
     {
          "algorithm": "The new algorithm employs adaptive clustering to refine candidate selection, integrates momentum-based trajectory alignment with lookahead evaluations, and uses a dynamically weighted scoring function to balance short-term efficiency with long-term structural coherence.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def adaptive_clustering(node, threshold_factor=1.5):\n        median_distance = np.median(distance_matrix[node])\n        return [n for n in unvisited_nodes if distance_matrix[node][n] <= threshold_factor * median_distance]\n    \n    def momentum_alignment(node):\n        return np.mean([distance_matrix[node][n] for n in unvisited_nodes if n != node]) if len(unvisited_nodes) > 1 else float('inf')\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    def structural_coherence(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    candidates = adaptive_clustering(current_node)\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def adaptive_clustering(node, threshold_factor=1.5):\n        median_distance = np.median(distance_matrix[node])\n        return [n for n in unvisited_nodes if distance_matrix[node][n] <= threshold_factor * median_distance]\n    \n    def momentum_alignment(node):\n        return np.mean([distance_matrix[node][n] for n in unvisited_nodes if n != node]) if len(unvisited_nodes) > 1 else float('inf')\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    def structural_coherence(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    candidates = adaptive_clustering(current_node)\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    median_distance = np.median(distance_matrix[current_node])\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        momentum_score = momentum_alignment(candidate)\n        lookahead_score = lookahead_evaluation(candidate)\n        coherence_score = structural_coherence([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        hybrid_score = (\n            0.4 * lookahead_score +\n            0.3 * coherence_score +\n            0.2 * normalized_cost +\n            0.1 * momentum_score\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.91811,
          "other_inf": null,
          "metadata": {
               "operator": "e1",
               "wisdom_tips": [
                    "Combine short-term trajectory evaluations with long-term structural coherence to guide decision-making in dynamic environments.",
                    "Use adaptive pruning strategies to focus computational resources on promising candidates while preserving diversity in the search space.",
                    "Balance short-term gains with long-term feasibility by integrating lookahead simulations and global structural coherence into decision scoring."
               ],
               "attention_focus": "fine-tuning critical algorithm parameters and thresholds",
               "generation_tendency": "balanced_search",
               "timestamp": 1758185822.718049
          }
     }
]