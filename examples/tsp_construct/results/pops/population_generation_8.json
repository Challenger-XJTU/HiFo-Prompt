[
     {
          "algorithm": "The new algorithm selects the next node by integrating adaptive candidate pruning with structural diversity, lookahead-based evaluations to balance exploration and exploitation, and a hybrid scoring mechanism that incorporates normalized costs, global MST coherence, and trajectory momentum.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        look_ahead_cost = lookahead_evaluation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        momentum_bonus = 0.5 * (1 - direct_cost / max(distance_matrix[current_node]))\n        hybrid_score = (\n            0.4 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost -\n            0.1 * momentum_bonus\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.92681,
          "other_inf": null,
          "metadata": {
               "operator": "e2",
               "wisdom_tips": [
                    "Dynamically balance exploration and exploitation by incorporating structural diversity and lookahead evaluations to guide decision-making while avoiding premature convergence.",
                    "Reduce computational overhead by adaptively pruning candidates based on normalized costs and focusing evaluations on a manageable subset of high-potential options.",
                    "Use heuristic-guided candidate selection to reduce the search space while preserving high-quality solution potential."
               ],
               "attention_focus": "optimizing established successful strategies and patterns",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758184549.645813
          }
     },
     {
          "algorithm": "The new algorithm selects the next node by dynamically balancing structural pruning, lookahead evaluations, and momentum-based scoring with adjusted weights to emphasize exploration while maintaining computational efficiency.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_momentum(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n    \n    def mst_pruning_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_momentum(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n    \n    def mst_pruning_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    scores = {}\n    median_distance = np.median(distance_matrix[current_node])\n    for candidate in unvisited_nodes:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        momentum_score = cluster_momentum(candidate)\n        lookahead_score = lookahead_simulation(candidate)\n        mst_score = mst_pruning_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        hybrid_score = (\n            0.5 * lookahead_score +\n            0.2 * mst_score +\n            0.2 * normalized_cost +\n            0.1 * momentum_score\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.93102,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Integrate adaptive pruning strategies with structural diversity to enhance exploration while maintaining computational efficiency.",
                    "Combine normalized cost metrics with lookahead-based evaluations to dynamically balance short-term gains and long-term solution coherence.",
                    "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations."
               ],
               "attention_focus": "managing computational complexity and time efficiency",
               "generation_tendency": "balanced_search",
               "timestamp": 1758185137.254592
          }
     },
     {
          "algorithm": "node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        look_ahead_cost = lookahead_evaluation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        hybrid_score = (\n            0.5 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.95081,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Integrate adaptive pruning strategies with structural diversity to enhance exploration while maintaining computational efficiency.",
                    "Combine normalized cost metrics with lookahead-based evaluations to dynamically balance short-term gains and long-term solution coherence.",
                    "Use normalized metrics and hybrid scoring mechanisms to ensure robustness against varying problem scales and complexities."
               ],
               "attention_focus": "fine-tuning critical algorithm parameters and thresholds",
               "generation_tendency": "balanced_search",
               "timestamp": 1758185183.04735
          }
     },
     {
          "algorithm": "The new algorithm dynamically prioritizes edge costs, lookahead-based global coherence, and structural diversity by adaptively weighting normalized costs, cluster quality, and long-term path feasibility while emphasizing exploration-exploitation balance through adjusted score function parameters.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_score(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n\n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n\n    def beam_search_candidates():\n        candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n        beams = []\n        for candidate in candidates:\n            direct_cost = distance_matrix[current_node][candidate]\n            lookahead_cost = lookahead_evaluation(candidate)\n            cluster_quality = cluster_score(candidate)\n            normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n            score = (\n                0.4 * lookahead_cost +\n                0.35 * cluster_quality +\n                0.15 * normalized_cost +\n                0.1 * direct_cost\n            )\n            beams.append((score, candidate))\n        beams.sort(key=lambda x: x[0])\n        return [node for _, node in beams[:min(3, len(beams))]]\n\n    candidate_beam = beam_search_candidates()\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_score(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n\n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n\n    def beam_search_candidates():\n        candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n        beams = []\n        for candidate in candidates:\n            direct_cost = distance_matrix[current_node][candidate]\n            lookahead_cost = lookahead_evaluation(candidate)\n            cluster_quality = cluster_score(candidate)\n            normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n            score = (\n                0.4 * lookahead_cost +\n                0.35 * cluster_quality +\n                0.15 * normalized_cost +\n                0.1 * direct_cost\n            )\n            beams.append((score, candidate))\n        beams.sort(key=lambda x: x[0])\n        return [node for _, node in beams[:min(3, len(beams))]]\n\n    candidate_beam = beam_search_candidates()\n    scores = {}\n    for candidate in candidate_beam:\n        direct_cost = distance_matrix[current_node][candidate]\n        lookahead_cost = lookahead_evaluation(candidate)\n        cluster_quality = cluster_score(candidate)\n        normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (\n            0.5 * lookahead_cost +\n            0.25 * cluster_quality +\n            0.15 * normalized_cost +\n            0.1 * direct_cost\n        )\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.95751,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Integrate adaptive pruning strategies with structural diversity to enhance exploration while maintaining computational efficiency.",
                    "Combine normalized cost metrics with lookahead-based evaluations to dynamically balance short-term gains and long-term solution coherence.",
                    "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations."
               ],
               "attention_focus": "considering long-term impact of current decisions",
               "generation_tendency": "balanced_search",
               "timestamp": 1758185159.838847
          }
     },
     {
          "algorithm": "A refined algorithm that dynamically adjusts scoring weights based on adaptive exploration-exploitation trade-offs, emphasizing structural diversity and normalized edge costs while incorporating lightweight lookahead simulations.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def structural_diversity(node):\n        cluster = sorted(unvisited_nodes, key=lambda x: distance_matrix[node][x])[:5]\n        return np.std([distance_matrix[node][n] for n in cluster])\n    \n    def lookahead_cost(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        total_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            total_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return total_cost + distance_matrix[last][destination_node]\n    \n    def normalized_edge_cost(node):\n        return distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n    \n    # Prune candidates to a smaller set based on direct cost\n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def structural_diversity(node):\n        cluster = sorted(unvisited_nodes, key=lambda x: distance_matrix[node][x])[:5]\n        return np.std([distance_matrix[node][n] for n in cluster])\n    \n    def lookahead_cost(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        total_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            total_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return total_cost + distance_matrix[last][destination_node]\n    \n    def normalized_edge_cost(node):\n        return distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n    \n    # Prune candidates to a smaller set based on direct cost\n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {}\n    random_factor = np.random.uniform(0.85, 1.15)  # Adjusted randomness range for adaptability\n    \n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        diversity_score = structural_diversity(candidate)\n        simulation_cost = lookahead_cost(candidate)\n        normalized_cost = normalized_edge_cost(candidate)\n        scores[candidate] = (\n            0.5 * simulation_cost * random_factor +\n            0.3 * diversity_score / random_factor +\n            0.1 * normalized_cost +\n            0.1 * direct_cost\n        )\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.95819,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Use adaptive scoring mechanisms that dynamically weigh multiple criteria, ensuring flexibility and responsiveness to problem-specific characteristics.",
                    "Use adaptive scoring mechanisms that dynamically weigh multiple factors (e.g., cost, cluster quality, and normalization) to prioritize decisions based on problem-specific characteristics.",
                    "Leverage hybrid meta-heuristics, combining structural insights (e.g., MST properties) with statistical evaluations (e.g., lightweight simulations) to guide decision-making robustly."
               ],
               "attention_focus": "refining core evaluation and scoring functions",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758184279.006243
          }
     },
     {
          "algorithm": "A streamlined algorithm that adaptively balances exploration and exploitation by dynamically pruning candidates, incorporating structural diversity, lookahead evaluations, and normalized edge costs while reducing redundant computations.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def structural_diversity(node):\n        cluster = sorted(unvisited_nodes, key=lambda x: distance_matrix[node][x])[:5]\n        return np.std([distance_matrix[node][n] for n in cluster])\n    \n    def lookahead_cost(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        total_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            total_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return total_cost + distance_matrix[last][destination_node]\n    \n    def normalized_edge_cost(node):\n        return distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n    \n    # Prune candidates to a smaller set based on direct cost\n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def structural_diversity(node):\n        cluster = sorted(unvisited_nodes, key=lambda x: distance_matrix[node][x])[:5]\n        return np.std([distance_matrix[node][n] for n in cluster])\n    \n    def lookahead_cost(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        total_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            total_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return total_cost + distance_matrix[last][destination_node]\n    \n    def normalized_edge_cost(node):\n        return distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n    \n    # Prune candidates to a smaller set based on direct cost\n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {}\n    random_factor = np.random.uniform(0.9, 1.1)  # Reduced randomness range for stability\n    \n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        diversity_score = structural_diversity(candidate)\n        simulation_cost = lookahead_cost(candidate)\n        normalized_cost = normalized_edge_cost(candidate)\n        scores[candidate] = (\n            0.6 * simulation_cost * random_factor +\n            0.2 * diversity_score / random_factor +\n            0.1 * normalized_cost +\n            0.1 * direct_cost\n        )\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.96,
          "other_inf": null,
          "metadata": {
               "operator": "m1",
               "wisdom_tips": [
                    "Use adaptive scoring mechanisms that incorporate structural diversity and lookahead evaluations to prune redundant computations and enhance robustness.",
                    "Use adaptive scoring mechanisms that dynamically weigh multiple criteria, ensuring flexibility and responsiveness to problem-specific characteristics.",
                    "Integrate dynamic weighting of objectives to balance exploration and exploitation based on problem-solving progress."
               ],
               "attention_focus": "reducing unnecessary computational overhead and redundancy",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758184219.5696461
          }
     },
     {
          "algorithm": "A new algorithm that uses adaptive cluster-aware lookahead and structural diversity scoring to prioritize nodes, reducing computational overhead by pruning redundant evaluations.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_score(node):\n        neighbors = sorted(unvisited_nodes, key=lambda x: distance_matrix[node][x])[:3]\n        return np.mean([distance_matrix[node][n] for n in neighbors])\n    \n    def lookahead_cost(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_score(node):\n        neighbors = sorted(unvisited_nodes, key=lambda x: distance_matrix[node][x])[:3]\n        return np.mean([distance_matrix[node][n] for n in neighbors])\n    \n    def lookahead_cost(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n    scores = {}\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        cluster_quality = cluster_score(candidate)\n        future_cost = lookahead_cost(candidate)\n        normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (\n            0.5 * future_cost +\n            0.3 * cluster_quality +\n            0.2 * normalized_cost\n        )\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.96144,
          "other_inf": null,
          "metadata": {
               "operator": "e2",
               "wisdom_tips": [
                    "Combine greedy local decisions with global structural insights to guide the search process effectively.",
                    "Use adaptive weighting and lookahead strategies to balance exploration in early stages with exploitation in later stages.",
                    "Integrate machine learning and domain-specific heuristics to dynamically adjust decision weights, ensuring exploration-exploitation trade-offs align with problem progress."
               ],
               "attention_focus": "reducing unnecessary computational overhead and redundancy",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758183783.619864
          }
     },
     {
          "algorithm": "The new algorithm selects the next node by adaptively weighting edge costs, cluster quality, and lookahead evaluations while dynamically emphasizing either local or global coherence based on a hybrid meta-heuristic approach.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_score(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n\n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n\n    def beam_search_candidates():\n        candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n        beams = []\n        for candidate in candidates:\n            direct_cost = distance_matrix[current_node][candidate]\n            lookahead_cost = lookahead_evaluation(candidate)\n            cluster_quality = cluster_score(candidate)\n            normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n            score = (\n                0.35 * lookahead_cost +\n                0.4 * cluster_quality +\n                0.15 * normalized_cost +\n                0.1 * direct_cost\n            )\n            beams.append((score, candidate))\n        beams.sort(key=lambda x: x[0])\n        return [node for _, node in beams[:min(3, len(beams))]]\n\n    candidate_beam = beam_search_candidates()\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_score(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n\n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n\n    def beam_search_candidates():\n        candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:min(5, len(unvisited_nodes))]\n        beams = []\n        for candidate in candidates:\n            direct_cost = distance_matrix[current_node][candidate]\n            lookahead_cost = lookahead_evaluation(candidate)\n            cluster_quality = cluster_score(candidate)\n            normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n            score = (\n                0.35 * lookahead_cost +\n                0.4 * cluster_quality +\n                0.15 * normalized_cost +\n                0.1 * direct_cost\n            )\n            beams.append((score, candidate))\n        beams.sort(key=lambda x: x[0])\n        return [node for _, node in beams[:min(3, len(beams))]]\n\n    candidate_beam = beam_search_candidates()\n    scores = {}\n    for candidate in candidate_beam:\n        direct_cost = distance_matrix[current_node][candidate]\n        lookahead_cost = lookahead_evaluation(candidate)\n        cluster_quality = cluster_score(candidate)\n        normalized_cost = direct_cost / (np.median(distance_matrix[current_node]) + 1e-6)\n        scores[candidate] = (\n            0.45 * lookahead_cost +\n            0.3 * cluster_quality +\n            0.2 * normalized_cost +\n            0.05 * direct_cost\n        )\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.96227,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Use adaptive scoring mechanisms that dynamically weigh multiple criteria, ensuring flexibility and responsiveness to problem-specific characteristics.",
                    "Use adaptive scoring mechanisms that dynamically weigh multiple factors (e.g., cost, cluster quality, and normalization) to prioritize decisions based on problem-specific characteristics.",
                    "Leverage hybrid meta-heuristics, combining structural insights (e.g., MST properties) with statistical evaluations (e.g., lightweight simulations) to guide decision-making robustly."
               ],
               "attention_focus": "fine-tuning critical algorithm parameters and thresholds",
               "generation_tendency": "balanced_search",
               "timestamp": 1758184299.636641
          }
     }
]