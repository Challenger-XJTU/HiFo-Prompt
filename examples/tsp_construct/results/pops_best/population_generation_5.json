{
     "algorithm": "The new algorithm incrementally selects the next node by prioritizing candidates based on a hybrid scoring function combining normalized edge costs, momentum-based trajectory alignment, MST-based global connectivity, and Monte Carlo-inspired lookahead simulations with adaptive weighting tuned for early exploration and late exploitation.}\n\n```python\nimport numpy as np\nfrom heapq import heappush, heappop\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes",
     "code": "import numpy as np\nfrom heapq import heappush, heappop\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path = [current_node, node]\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[path[-1]][x])\n            path.append(next_step)\n            remaining_nodes.remove(next_step)\n        return sum(distance_matrix[path[i]][path[i+1]] for i in range(len(path)-1))\n    \n    priority_queue = []\n    adaptive_weight = np.random.uniform(0.6, 1.4)\n    median_distance = np.median(distance_matrix[current_node])\n    \n    for candidate in unvisited_nodes:\n        direct_cost = distance_matrix[current_node][candidate]\n        look_ahead_cost = lookahead_simulation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        momentum_bonus = 0.5 * (1 - direct_cost / max(distance_matrix[current_node]))\n        hybrid_score = (adaptive_weight * look_ahead_cost) + (0.9 * mst_remaining) + (0.3 * normalized_cost) - momentum_bonus\n        heappush(priority_queue, (hybrid_score, candidate))\n    \n    next_node = heappop(priority_queue)[1]\n    return next_node",
     "objective": 5.98521,
     "other_inf": null,
     "metadata": {
          "operator": "m2",
          "wisdom_tips": [
               "Use incremental, greedy decisions to build solutions while preserving global constraints through efficient data structures (e.g., union-find for connectivity tracking).",
               "Leverage heuristic-guided exploration to efficiently evaluate candidate choices, focusing on a subset of high-potential options to balance computational cost and solution quality.",
               "Design adaptive hybrid meta-heuristics synergistically fusing multiple search paradigms and dynamically tune operator parameters based on search stage or problem features"
          ],
          "attention_focus": "experimenting with hybrid strategy combinations",
          "generation_tendency": "balanced_search",
          "timestamp": 1758182841.285204
     }
}