[
     {
          "algorithm": "A hybrid algorithm that combines dynamic candidate pruning, trajectory-aware lookahead simulations, and a scoring mechanism integrating normalized edge costs, structural coherence via MST fragments, and path momentum with probabilistic MCTS-inspired rollouts.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        max_cost = max(distance_matrix[current_node])\n        return 1 - (direct_cost / max_cost)\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = momentum_score(node)\n        return (\n            0.4 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Prune candidates based on normalized edge costs\n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using hybrid scoring\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        max_cost = max(distance_matrix[current_node])\n        return 1 - (direct_cost / max_cost)\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = momentum_score(node)\n        return (\n            0.4 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Prune candidates based on normalized edge costs\n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using hybrid scoring\n    scores = {}\n    for candidate in candidates:\n        scores[candidate] = hybrid_score(candidate)\n    \n    # Select the next node with the lowest hybrid score\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.88828,
          "other_inf": null,
          "metadata": {
               "operator": "e1",
               "wisdom_tips": [
                    "Use normalized metrics and hybrid scoring mechanisms to ensure robustness against varying problem scales and complexities.",
                    "Integrate lookahead-based evaluations to balance exploration and exploitation, ensuring decisions are informed by both immediate costs and future trajectory impacts.",
                    "Use hybrid scoring mechanisms that combine multiple metrics (e.g., normalized costs, structural coherence, and momentum) to dynamically adapt to problem-specific trade-offs."
               ],
               "attention_focus": "experimenting with hybrid strategy combinations",
               "generation_tendency": "balanced_search",
               "timestamp": 1758185290.9559622
          }
     },
     {
          "algorithm": "A hybrid algorithm that balances short-term gains with long-term feasibility by reweighting normalized edge costs, MST coherence, and adaptive momentum with a stronger emphasis on global structure.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def adaptive_momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        avg_cost = np.mean(distance_matrix[current_node])\n        scaled_momentum = 1 - (direct_cost / (avg_cost + 1e-6))\n        return scaled_momentum ** 3  # Cubic to further emphasize high-momentum choices\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = adaptive_momentum_score(node)\n        return (\n            0.4 * look_ahead_cost +\n            0.35 * mst_remaining +\n            0.15 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Dynamically adjust candidate threshold based on unvisited node density\n    median_distance = np.median(distance_matrix[current_node])\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    threshold_factor = (1.5 + 0.5 * density_factor) * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using refined hybrid scoring\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_fragment_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining = list(unvisited_nodes)\n        remaining.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last = node\n        while remaining:\n            next_step = min(remaining, key=lambda x: distance_matrix[last][x])\n            path_cost += distance_matrix[last][next_step]\n            last = next_step\n            remaining.remove(next_step)\n        return path_cost + distance_matrix[last][destination_node]\n    \n    def adaptive_momentum_score(node):\n        direct_cost = distance_matrix[current_node][node]\n        avg_cost = np.mean(distance_matrix[current_node])\n        scaled_momentum = 1 - (direct_cost / (avg_cost + 1e-6))\n        return scaled_momentum ** 3  # Cubic to further emphasize high-momentum choices\n    \n    def hybrid_score(node):\n        normalized_cost = distance_matrix[current_node][node] / (np.median(distance_matrix[current_node]) + 1e-6)\n        look_ahead_cost = lookahead_simulation(node)\n        mst_remaining = mst_fragment_cost([destination_node] + [n for n in unvisited_nodes if n != node])\n        momentum = adaptive_momentum_score(node)\n        return (\n            0.4 * look_ahead_cost +\n            0.35 * mst_remaining +\n            0.15 * normalized_cost -\n            0.1 * momentum\n        )\n    \n    # Dynamically adjust candidate threshold based on unvisited node density\n    median_distance = np.median(distance_matrix[current_node])\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    threshold_factor = (1.5 + 0.5 * density_factor) * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    # Evaluate candidates using refined hybrid scoring\n    scores = {}\n    for candidate in candidates:\n        scores[candidate] = hybrid_score(candidate)\n    \n    # Select the next node with the lowest hybrid score\n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.90634,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Use hybrid scoring mechanisms that combine normalized local costs, global structural coherence, and dynamic adaptability to guide decision-making effectively.",
                    "**Evaluate candidates using a greedy heuristic that prioritizes short-term gains while approximating long-term feasibility.**",
                    "Use incremental, greedy decisions to build solutions while preserving global constraints through efficient data structures (e.g., union-find for connectivity tracking)."
               ],
               "attention_focus": "investigating alternative problem decomposition approaches",
               "generation_tendency": "focus_exploration",
               "timestamp": 1758185586.6458108
          }
     },
     {
          "algorithm": "The new algorithm employs adaptive clustering to refine candidate selection, integrates momentum-based trajectory alignment with lookahead evaluations, and uses a dynamically weighted scoring function to balance short-term efficiency with long-term structural coherence.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def adaptive_clustering(node, threshold_factor=1.5):\n        median_distance = np.median(distance_matrix[node])\n        return [n for n in unvisited_nodes if distance_matrix[node][n] <= threshold_factor * median_distance]\n    \n    def momentum_alignment(node):\n        return np.mean([distance_matrix[node][n] for n in unvisited_nodes if n != node]) if len(unvisited_nodes) > 1 else float('inf')\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    def structural_coherence(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    candidates = adaptive_clustering(current_node)\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def adaptive_clustering(node, threshold_factor=1.5):\n        median_distance = np.median(distance_matrix[node])\n        return [n for n in unvisited_nodes if distance_matrix[node][n] <= threshold_factor * median_distance]\n    \n    def momentum_alignment(node):\n        return np.mean([distance_matrix[node][n] for n in unvisited_nodes if n != node]) if len(unvisited_nodes) > 1 else float('inf')\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    def structural_coherence(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    candidates = adaptive_clustering(current_node)\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    median_distance = np.median(distance_matrix[current_node])\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        momentum_score = momentum_alignment(candidate)\n        lookahead_score = lookahead_evaluation(candidate)\n        coherence_score = structural_coherence([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        hybrid_score = (\n            0.4 * lookahead_score +\n            0.3 * coherence_score +\n            0.2 * normalized_cost +\n            0.1 * momentum_score\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.91811,
          "other_inf": null,
          "metadata": {
               "operator": "e1",
               "wisdom_tips": [
                    "Combine short-term trajectory evaluations with long-term structural coherence to guide decision-making in dynamic environments.",
                    "Use adaptive pruning strategies to focus computational resources on promising candidates while preserving diversity in the search space.",
                    "Balance short-term gains with long-term feasibility by integrating lookahead simulations and global structural coherence into decision scoring."
               ],
               "attention_focus": "fine-tuning critical algorithm parameters and thresholds",
               "generation_tendency": "balanced_search",
               "timestamp": 1758185822.718049
          }
     },
     {
          "algorithm": "The new algorithm selects the next node by integrating adaptive candidate pruning with structural diversity, lookahead-based evaluations to balance exploration and exploitation, and a hybrid scoring mechanism that incorporates normalized costs, global MST coherence, and trajectory momentum.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        look_ahead_cost = lookahead_evaluation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        momentum_bonus = 0.5 * (1 - direct_cost / max(distance_matrix[current_node]))\n        hybrid_score = (\n            0.4 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost -\n            0.1 * momentum_bonus\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.92681,
          "other_inf": null,
          "metadata": {
               "operator": "e2",
               "wisdom_tips": [
                    "Dynamically balance exploration and exploitation by incorporating structural diversity and lookahead evaluations to guide decision-making while avoiding premature convergence.",
                    "Reduce computational overhead by adaptively pruning candidates based on normalized costs and focusing evaluations on a manageable subset of high-potential options.",
                    "Use heuristic-guided candidate selection to reduce the search space while preserving high-quality solution potential."
               ],
               "attention_focus": "optimizing established successful strategies and patterns",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758184549.645813
          }
     },
     {
          "algorithm": "The new algorithm dynamically adjusts scoring weights based on node density and integrates adaptive momentum thresholds while emphasizing MST coherence and lookahead evaluations for robust path selection.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.2 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.2 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        look_ahead_cost = lookahead_evaluation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        momentum_bonus = 0.3 * (1 - direct_cost / max(distance_matrix[current_node]))\n        hybrid_score = (\n            (0.5 - 0.1 * density_factor) * look_ahead_cost +\n            (0.3 + 0.1 * density_factor) * mst_remaining +\n            0.2 * normalized_cost -\n            (0.1 + 0.05 * density_factor) * momentum_bonus\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.92811,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Combine short-term decision metrics with long-term structural coherence to guide solution exploration effectively.",
                    "Use adaptive scoring mechanisms that dynamically adjust thresholds and weights based on instance-specific properties like density or cost distributions.",
                    "Combine short-term heuristic evaluations with long-term structural considerations to guide decision-making effectively."
               ],
               "attention_focus": "optimizing established successful strategies and patterns",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758186151.847371
          }
     },
     {
          "algorithm": "The new algorithm selects the next node by dynamically balancing structural pruning, lookahead evaluations, and momentum-based scoring with adjusted weights to emphasize exploration while maintaining computational efficiency.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_momentum(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n    \n    def mst_pruning_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def cluster_momentum(node):\n        distances = [distance_matrix[node][n] for n in unvisited_nodes if n != node]\n        return np.mean(distances) if distances else float('inf')\n    \n    def mst_pruning_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_simulation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    scores = {}\n    median_distance = np.median(distance_matrix[current_node])\n    for candidate in unvisited_nodes:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        momentum_score = cluster_momentum(candidate)\n        lookahead_score = lookahead_simulation(candidate)\n        mst_score = mst_pruning_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        hybrid_score = (\n            0.5 * lookahead_score +\n            0.2 * mst_score +\n            0.2 * normalized_cost +\n            0.1 * momentum_score\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.93102,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Integrate adaptive pruning strategies with structural diversity to enhance exploration while maintaining computational efficiency.",
                    "Combine normalized cost metrics with lookahead-based evaluations to dynamically balance short-term gains and long-term solution coherence.",
                    "Dynamically balance exploration of new options and exploitation of known good choices through adaptive weighting and lookahead simulations."
               ],
               "attention_focus": "managing computational complexity and time efficiency",
               "generation_tendency": "balanced_search",
               "timestamp": 1758185137.254592
          }
     },
     {
          "algorithm": "node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    density_factor = len(unvisited_nodes) / len(distance_matrix)\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        look_ahead_cost = lookahead_evaluation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        hybrid_score = (\n            0.4 * look_ahead_cost +\n            0.4 * mst_remaining +\n            0.2 * normalized_cost\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.93537,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Combine short-term decision metrics with long-term structural coherence to guide solution exploration effectively.",
                    "Use adaptive scoring mechanisms that dynamically adjust thresholds and weights based on instance-specific properties like density or cost distributions.",
                    "Combine short-term heuristic evaluations with long-term structural considerations to guide decision-making effectively."
               ],
               "attention_focus": "fine-tuning critical algorithm parameters and thresholds",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758186223.076171
          }
     },
     {
          "algorithm": "Design a node selection strategy that dynamically adjusts scoring weights based on instance-specific cost distributions and emphasizes long-term coherence through adaptive MST-based evaluations.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.2 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.2 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        look_ahead_cost = lookahead_evaluation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        hybrid_score = (\n            0.4 * look_ahead_cost +\n            0.4 * mst_remaining +\n            0.2 * normalized_cost\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
          "objective": 5.93958,
          "other_inf": null,
          "metadata": {
               "operator": "m2",
               "wisdom_tips": [
                    "Combine short-term decision metrics with long-term structural coherence to guide solution exploration effectively.",
                    "Use adaptive scoring mechanisms that dynamically adjust thresholds and weights based on instance-specific properties like density or cost distributions.",
                    "Combine short-term heuristic evaluations with long-term structural considerations to guide decision-making effectively."
               ],
               "attention_focus": "improving precision of existing heuristics and rules",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1758186151.826899
          }
     }
]