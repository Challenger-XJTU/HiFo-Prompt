[
     {
          "algorithm": "```",
          "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    n_train = train_x.size(0)\n    n_test = test_x.size(0)\n\n    # Simplified exploration: Compute average distance to training data\n    pairwise_distances = torch.cdist(test_x.unsqueeze(1), train_x.unsqueeze(0), p=2).squeeze(1)\n    avg_distance = torch.mean(pairwise_distances, dim=1)\n    max_distance = torch.max(torch.cdist(train_x, train_x)).item()\n    normalized_exploration = avg_distance / (max_distance + 1e-8)\n\n    # Simplified exploitation: Confidence bound with reduced complexity\n    confidence_bounds = mean_test_y + std_test_y\n\n    # Simplified cost-aware efficiency: Scale by inverse cost and remaining budget ratio\n    remaining_budget_ratio = (budget_total - budget_used) / (budget_total + 1e-8)\n    cost_efficiency = torch.exp(-cost_test_y) * remaining_budget_ratio\n\n    # Hybrid utility: Combine terms with static weights for simplicity\n    utility_value = (\n        0.5 * confidence_bounds +\n        0.3 * normalized_exploration +\n        0.2 * cost_efficiency\n    )\n\n    return utility_value",
          "objective": 2.13095,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Incorporate cost-aware penalties that evolve with resource depletion to ensure efficient utilization of limited resources.",
                    "Integrate cost-awareness into utility computations to ensure efficient allocation of resources while pursuing high-reward solutions.",
                    "Integrate cost-aware strategies that allocate resources efficiently while accounting for both predictive accuracy and variability in unobserved outcomes."
               ],
               "attention_focus": "experimenting with hybrid strategy combinations",
               "generation_tendency": "focus_exploration",
               "timestamp": 1752310847.962682
          }
     },
     {
          "algorithm": "A hybrid utility algorithm that combines cost-sensitive exploration with uncertainty-guided exploitation, while adaptively balancing resource allocation through a dynamic penalty-scaling mechanism.",
          "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    n_train = train_x.size(0)\n    n_test = test_x.size(0)\n\n    # Dynamic penalty scaling based on remaining budget and cost variability\n    remaining_budget_ratio = (budget_total - budget_used) / (budget_total + 1e-8)\n    cost_variability = torch.std(cost_test_y) / (torch.mean(cost_test_y) + 1e-8)\n    cost_penalty_scale = 1.0 + remaining_budget_ratio * cost_variability\n    cost_penalty = torch.log1p(cost_test_y / (torch.mean(cost_test_y) + 1e-8)) ** cost_penalty_scale\n\n    # Uncertainty-guided exploitation with distance-aware weighting\n    dist_to_best = torch.norm(test_x - best_x, dim=1)\n    max_dist = torch.max(torch.cdist(train_x, train_x)).item()\n    normalized_dist = dist_to_best / (max_dist + 1e-8)\n    exploitation_weight = torch.exp(-normalized_dist) * (mean_test_y - best_y)\n\n    # Cost-sensitive exploration with adaptive sensitivity scaling\n    avg_knn_distance = torch.mean(torch.cdist(test_x, train_x), dim=1)\n    exploration_sensitivity = 1.0 + torch.rand(n_test, dtype=torch.float64) * remaining_budget_ratio\n    exploration_weight = std_test_y / (avg_knn_distance + 1e-8) ** exploration_sensitivity\n\n    # Hybrid strategy integration with randomized adaptive modulation\n    random_modulation = torch.rand(n_test, dtype=torch.float64) * remaining_budget_ratio\n    utility_value = (\n        (1.0 - random_modulation) * exploitation_weight +\n        random_modulation * exploration_weight -\n        cost_penalty\n    )\n\n    return utility_value",
          "objective": 2.3243,
          "other_inf": null,
          "metadata": {
               "operator": "m1",
               "wisdom_tips": [
                    "Integrate cost-awareness into utility computations to ensure efficient allocation of resources while pursuing high-reward solutions.",
                    "Integrate cost-aware strategies that allocate resources efficiently while accounting for both predictive accuracy and variability in unobserved outcomes.",
                    "Construct problem specialized efficient solution representations and co design dedicated core operators to fully leverage representation structure for powerful solution space exploration"
               ],
               "attention_focus": "experimenting with hybrid strategy combinations",
               "generation_tendency": "focus_exploration",
               "timestamp": 1752310098.805783
          }
     },
     {
          "algorithm": "```",
          "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    n_train = train_x.size(0)\n    n_test = test_x.size(0)\n\n    # Simplified dynamic penalty scaling based on remaining budget\n    remaining_budget_ratio = (budget_total - budget_used) / (budget_total + 1e-8)\n    cost_penalty = torch.log1p(cost_test_y / (torch.mean(cost_test_y) + 1e-8)) ** (1.0 + remaining_budget_ratio)\n\n    # Simplified uncertainty-guided exploitation with normalized distance\n    dist_to_best = torch.norm(test_x - best_x, dim=1)\n    max_dist = torch.max(torch.cdist(train_x, train_x)).item()\n    normalized_dist = dist_to_best / (max_dist + 1e-8)\n    exploitation_weight = torch.exp(-normalized_dist) * (mean_test_y - best_y)\n\n    # Simplified cost-sensitive exploration with adaptive sensitivity\n    avg_knn_distance = torch.mean(torch.cdist(test_x, train_x), dim=1)\n    exploration_sensitivity = 1.0 + remaining_budget_ratio\n    exploration_weight = std_test_y / (avg_knn_distance + 1e-8) ** exploration_sensitivity\n\n    # Simplified hybrid strategy integration\n    utility_value = exploitation_weight + remaining_budget_ratio * exploration_weight - cost_penalty\n\n    return utility_value",
          "objective": 2.54366,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Dynamically modulate exploration-exploitation trade-offs using uncertainty-guided and cost-sensitive strategies to enhance solution quality and efficiency.",
                    "Integrate adaptive resource allocation mechanisms that scale based on problem-specific feedback to optimize performance across diverse instances.",
                    "Dynamically modulate the exploration-exploitation tradeoff based on resource constraints and problem uncertainty to enhance decision robustness."
               ],
               "attention_focus": "improving precision of existing heuristics and rules",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1752310666.1597
          }
     },
     {
          "algorithm": "A novel utility algorithm that integrates randomized adaptive weighting of cost-efficiency and uncertainty, while dynamically modulating exploration-exploitation balance through a stochastic threshold mechanism.",
          "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    n_train = train_x.size(0)\n    n_test = test_x.size(0)\n\n    # Randomized adaptive weighting factor for exploration-exploitation tradeoff\n    remaining_budget_ratio = (budget_total - budget_used) / (budget_total + 1e-8)\n    random_weight = torch.rand(n_test, dtype=torch.float64) * remaining_budget_ratio\n    exploitation_weight = 1.0 - random_weight\n    exploration_weight = random_weight\n\n    # Stochastic threshold mechanism for exploitation prioritization\n    dist_to_best = torch.norm(test_x - best_x, dim=1)\n    max_dist = torch.max(torch.cdist(train_x, train_x)).item()\n    normalized_dist = dist_to_best / (max_dist + 1e-8)\n    stochastic_threshold = torch.rand(n_test, dtype=torch.float64) * (1.0 - remaining_budget_ratio)\n    exploitation_mask = (normalized_dist < stochastic_threshold).double()\n\n    # Cost-efficiency modulation with randomized sensitivity scaling\n    avg_cost = torch.mean(cost_test_y)\n    cost_sensitivity = 1.0 + torch.rand(n_test, dtype=torch.float64) * remaining_budget_ratio\n    cost_penalty = torch.log1p(cost_test_y / (avg_cost + 1e-8)) ** cost_sensitivity\n\n    # Uncertainty modulation with feature-space density awareness\n    knn_distances = torch.cdist(test_x, train_x)\n    avg_knn_distance = torch.mean(knn_distances, dim=1)\n    uncertainty_modulation = std_test_y / (avg_knn_distance + 1e-8)\n\n    # Combine terms into the utility function with randomized adaptive weighting\n    utility_value = (\n        exploitation_weight * exploitation_mask * mean_test_y +\n        exploration_weight * uncertainty_modulation -\n        cost_penalty\n    )\n\n    return utility_value",
          "objective": 2.73726,
          "other_inf": null,
          "metadata": {
               "operator": "e1",
               "wisdom_tips": [
                    "Integrate cost-awareness into utility computations to ensure efficient allocation of resources while pursuing high-reward solutions.",
                    "Integrate cost-aware strategies that allocate resources efficiently while accounting for both predictive accuracy and variability in unobserved outcomes.",
                    "Construct problem specialized efficient solution representations and co design dedicated core operators to fully leverage representation structure for powerful solution space exploration"
               ],
               "attention_focus": "introducing new randomization or adaptive mechanisms",
               "generation_tendency": "focus_exploration",
               "timestamp": 1752309498.242002
          }
     },
     {
          "algorithm": "```",
          "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    n_train = train_x.size(0)\n    n_test = test_x.size(0)\n\n    # Simplified curvature sensitivity: focus on proximity to training data\n    knn_distances = torch.cdist(test_x, train_x)\n    avg_knn_distance = torch.mean(knn_distances, dim=1)\n    curvature_sensitivity = 1.0 / (avg_knn_distance + 1e-8)\n\n    # Simplified gain normalization: emphasize relative improvement over best observed\n    normalized_gain = (mean_test_y - torch.max(train_y)) / (torch.abs(torch.max(train_y) - torch.min(train_y)) + 1e-8)\n\n    # Simplified cost-aware allocation: prioritize low-cost regions with diminishing returns\n    remaining_budget_ratio = (budget_total - budget_used) / (budget_total + 1e-8)\n    cost_efficiency = torch.exp(-cost_test_y / (torch.mean(cost_test_y) + 1e-8)) * remaining_budget_ratio\n\n    # Combine simplified terms into the utility function\n    utility_value = (\n        normalized_gain +\n        std_test_y * curvature_sensitivity +\n        cost_efficiency\n    )\n\n    return utility_value",
          "objective": 3.1615,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Incorporate cost-aware penalties that evolve with resource depletion to ensure efficient utilization of limited resources.",
                    "Integrate cost-awareness into utility computations to ensure efficient allocation of resources while pursuing high-reward solutions.",
                    "Integrate cost-aware strategies that allocate resources efficiently while accounting for both predictive accuracy and variability in unobserved outcomes."
               ],
               "attention_focus": "exploring novel solution construction methodologies",
               "generation_tendency": "focus_exploration",
               "timestamp": 1752310920.824793
          }
     },
     {
          "algorithm": "```",
          "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    n_train, dim = train_x.shape\n    n_test = test_x.shape[0]\n    \n    # Compute normalized remaining budget\n    remaining_budget = (budget_total - budget_used) / budget_total\n    \n    # Simplified exploration term: directly scale by remaining budget\n    exploration_term = std_test_y * remaining_budget\n    \n    # Simplified exploitation term: focus on predicted mean and penalize distance to best solution\n    distance_to_best = torch.norm(test_x - best_x, dim=1)\n    exploitation_term = mean_test_y / (1 + distance_to_best)\n    \n    # Simplified cost penalty: emphasize cost efficiency as budget decreases\n    cost_penalty = cost_test_y * (1 - remaining_budget)\n    \n    # Combine terms into utility function with equal weighting\n    utility_value = exploitation_term + exploration_term - cost_penalty\n    \n    return utility_value",
          "objective": 3.66957,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Dynamically adjust the exploration-exploitation tradeoff by incorporating cost-aware budget allocation and historical performance feedback to optimize resource utilization.",
                    "Integrate adaptive objective transformations and diversification strategies to systematically target underexplored regions while maintaining a balance between search efficiency and solution quality.",
                    "Implement intelligent diversification and restart strategies based on solution feature space analysis systematically targeting uncovered feature regions to promote global search coverage and escape deep local optima"
               ],
               "attention_focus": "investigating alternative problem decomposition approaches",
               "generation_tendency": "focus_exploration",
               "timestamp": 1752308875.232694
          }
     },
     {
          "algorithm": "A novel utility algorithm that integrates cost-aware dynamic allocation with feature-space curvature sensitivity, while adaptively balancing exploration-exploitation through normalized predictive gain scaling.",
          "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    n_train = train_x.size(0)\n    n_test = test_x.size(0)\n\n    # Feature-space curvature sensitivity: measure local smoothness via second-order differences\n    knn_distances = torch.cdist(test_x, train_x)\n    avg_knn_distance = torch.mean(knn_distances, dim=1)\n    curvature_sensitivity = 1.0 / (avg_knn_distance + 1e-8)\n\n    # Predictive gain normalization: scale mean predictions relative to observed progress\n    normalized_gain = (mean_test_y - torch.max(train_y)) / (torch.abs(torch.max(train_y) - torch.min(train_y)) + 1e-8)\n\n    # Cost-aware dynamic allocation: prioritize low-cost regions with diminishing returns\n    remaining_budget_ratio = (budget_total - budget_used) / (budget_total + 1e-8)\n    cost_efficiency = torch.exp(-cost_test_y / (torch.mean(cost_test_y) + 1e-8)) * remaining_budget_ratio\n\n    # Uncertainty modulation: balance variability with curvature sensitivity\n    modulated_uncertainty = std_test_y * curvature_sensitivity\n\n    # Adaptive exploration-exploitation weighting via normalized gain\n    exploration_weight = torch.sigmoid(normalized_gain)  # Higher gain encourages exploitation\n    exploitation_weight = 1.0 - exploration_weight\n\n    # Combine terms into the utility function with curvature-sensitive scaling\n    utility_value = (\n        exploitation_weight * normalized_gain +\n        exploration_weight * modulated_uncertainty +\n        cost_efficiency\n    )\n\n    return utility_value",
          "objective": 3.91598,
          "other_inf": null,
          "metadata": {
               "operator": "e2",
               "wisdom_tips": [
                    "Integrate cost-awareness into utility computations to ensure efficient allocation of resources while pursuing high-reward solutions.",
                    "Integrate cost-aware strategies that allocate resources efficiently while accounting for both predictive accuracy and variability in unobserved outcomes.",
                    "Construct problem specialized efficient solution representations and co design dedicated core operators to fully leverage representation structure for powerful solution space exploration"
               ],
               "attention_focus": "refining core evaluation and scoring functions",
               "generation_tendency": "focus_exploitation",
               "timestamp": 1752309564.940268
          }
     },
     {
          "algorithm": "```",
          "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    n_train = train_x.size(0)\n    n_test = test_x.size(0)\n\n    # Simplified adaptive objective transformation\n    scaled_mean = torch.log1p(mean_test_y - torch.min(train_y) + 1e-8)\n\n    # Simplified cost-aware budget allocation\n    remaining_budget_ratio = (budget_total - budget_used) / (budget_total + 1e-8)\n    cost_efficiency = torch.exp(-cost_test_y / (torch.mean(cost_test_y) + 1e-8)) * remaining_budget_ratio\n\n    # Simplified uncertainty modulation\n    knn_distances = torch.cdist(test_x, train_x)\n    avg_knn_distance = torch.mean(knn_distances, dim=1)\n    modulated_uncertainty = std_test_y / (avg_knn_distance + 1e-8)\n\n    # Combine terms with static weights for exploration-exploitation tradeoff\n    utility_value = (\n        0.6 * scaled_mean +\n        0.4 * modulated_uncertainty +\n        cost_efficiency\n    )\n\n    return utility_value",
          "objective": 4.18607,
          "other_inf": null,
          "metadata": {
               "operator": "m3",
               "wisdom_tips": [
                    "Dynamically modulate exploration-exploitation trade-offs using uncertainty-guided and cost-sensitive strategies to enhance solution quality and efficiency.",
                    "Integrate adaptive resource allocation mechanisms that scale based on problem-specific feedback to optimize performance across diverse instances.",
                    "Dynamically modulate the exploration-exploitation tradeoff based on resource constraints and problem uncertainty to enhance decision robustness."
               ],
               "attention_focus": "managing computational complexity and time efficiency",
               "generation_tendency": "balanced_search",
               "timestamp": 1752310601.123442
          }
     }
]