{
     "algorithm": "The new algorithm selects the next node by integrating adaptive candidate pruning with structural diversity, lookahead-based evaluations to balance exploration and exploitation, and a hybrid scoring mechanism that incorporates normalized costs, global MST coherence, and trajectory momentum.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {",
     "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = sorted([(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j], key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        \n        def find(node):\n            while parent[node] != node:\n                parent[node] = parent[parent[node]]\n                node = parent[node]\n            return node\n        \n        def union(node1, node2):\n            root1 = find(node1)\n            root2 = find(node2)\n            if root1 != root2:\n                parent[root2] = root1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def lookahead_evaluation(node):\n        remaining_nodes = list(unvisited_nodes)\n        remaining_nodes.remove(node)\n        path_cost = distance_matrix[current_node][node]\n        last_node = node\n        while remaining_nodes:\n            next_step = min(remaining_nodes, key=lambda x: distance_matrix[last_node][x])\n            path_cost += distance_matrix[last_node][next_step]\n            last_node = next_step\n            remaining_nodes.remove(next_step)\n        return path_cost + distance_matrix[last_node][destination_node]\n    \n    median_distance = np.median(distance_matrix[current_node])\n    threshold_factor = 1.5 * median_distance\n    candidates = [n for n in unvisited_nodes if distance_matrix[current_node][n] <= threshold_factor]\n    if not candidates:\n        candidates = list(unvisited_nodes)\n    \n    scores = {}\n    for candidate in candidates:\n        direct_cost = distance_matrix[current_node][candidate]\n        normalized_cost = direct_cost / (median_distance + 1e-6)\n        look_ahead_cost = lookahead_evaluation(candidate)\n        mst_remaining = mst_cost([destination_node] + [n for n in unvisited_nodes if n != candidate])\n        momentum_bonus = 0.5 * (1 - direct_cost / max(distance_matrix[current_node]))\n        hybrid_score = (\n            0.4 * look_ahead_cost +\n            0.3 * mst_remaining +\n            0.2 * normalized_cost -\n            0.1 * momentum_bonus\n        )\n        scores[candidate] = hybrid_score\n    \n    next_node = min(scores, key=scores.get)\n    return next_node",
     "objective": 5.92681,
     "other_inf": null,
     "metadata": {
          "operator": "e2",
          "wisdom_tips": [
               "Dynamically balance exploration and exploitation by incorporating structural diversity and lookahead evaluations to guide decision-making while avoiding premature convergence.",
               "Reduce computational overhead by adaptively pruning candidates based on normalized costs and focusing evaluations on a manageable subset of high-potential options.",
               "Use heuristic-guided candidate selection to reduce the search space while preserving high-quality solution potential."
          ],
          "attention_focus": "optimizing established successful strategies and patterns",
          "generation_tendency": "focus_exploitation",
          "timestamp": 1758184549.645813
     }
}