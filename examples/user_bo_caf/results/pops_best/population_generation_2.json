{
     "algorithm": "```",
     "code": "import torch\n\ndef utility(train_x, train_y, best_x, best_y, test_x, mean_test_y, std_test_y, cost_test_y, budget_used, budget_total):\n    n_train = train_x.size(0)\n    n_test = test_x.size(0)\n\n    # Simplified exploration: Compute average distance to training data\n    pairwise_distances = torch.cdist(test_x.unsqueeze(1), train_x.unsqueeze(0), p=2).squeeze(1)\n    avg_distance = torch.mean(pairwise_distances, dim=1)\n    max_distance = torch.max(torch.cdist(train_x, train_x)).item()\n    normalized_exploration = avg_distance / (max_distance + 1e-8)\n\n    # Simplified exploitation: Confidence bound with reduced complexity\n    confidence_bounds = mean_test_y + std_test_y\n\n    # Simplified cost-aware efficiency: Scale by inverse cost and remaining budget ratio\n    remaining_budget_ratio = (budget_total - budget_used) / (budget_total + 1e-8)\n    cost_efficiency = torch.exp(-cost_test_y) * remaining_budget_ratio\n\n    # Hybrid utility: Combine terms with static weights for simplicity\n    utility_value = (\n        0.5 * confidence_bounds +\n        0.3 * normalized_exploration +\n        0.2 * cost_efficiency\n    )\n\n    return utility_value",
     "objective": 2.13095,
     "other_inf": null,
     "metadata": {
          "operator": "m3",
          "wisdom_tips": [
               "Incorporate cost-aware penalties that evolve with resource depletion to ensure efficient utilization of limited resources.",
               "Integrate cost-awareness into utility computations to ensure efficient allocation of resources while pursuing high-reward solutions.",
               "Integrate cost-aware strategies that allocate resources efficiently while accounting for both predictive accuracy and variability in unobserved outcomes."
          ],
          "attention_focus": "experimenting with hybrid strategy combinations",
          "generation_tendency": "focus_exploration",
          "timestamp": 1752310847.962682
     }
}