[
     {
          "algorithm": "The algorithm iteratively selects the next node by maintaining a candidate set of promising neighbors, using look-ahead evaluation and MST-based cost normalization while incorporating path momentum, nearest neighbor clusters, MCTS-inspired simulations, and beam search to balance local optimality with global tour quality.}\n\n```python\nimport numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost_estimate(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = [(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j]\n        edges.sort(key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        rank = {node: 0 for node in nodes}\n        \n        def find(u):\n            while parent[u] != u:\n                parent[u] = parent[parent[u]]\n                u = parent[u]\n            return u\n        \n        def union(u, v):\n            root_u = find(u)\n            root_v = find(v)\n            if root_u != root_v:\n                if rank[root_u] > rank[root_v]:\n                    parent[root_v] = root_u\n                elif rank[root_u] < rank[root_v]:\n                    parent[root_u] = root_v\n                else:\n                    parent[root_v] = root_u\n                    rank[root_u] += 1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def simulate_path(node, remaining_nodes, steps=3):\n        if steps == 0 or len(remaining_nodes) == 0:\n            return 0\n        candidates = sorted(remaining_nodes, key=lambda x: distance_matrix[node][x])[:5]\n        best_score = float('inf')\n        for candidate in candidates:\n            new_remaining = [n for n in remaining_nodes if n != candidate]\n            score = distance_matrix[node][candidate] + simulate_path(candidate, new_remaining, steps - 1)\n            best_score = min(best_score, score)\n        return best_score\n    \n    def beam_search(candidates, beam_width=3):\n        paths = [(current_node, [current_node], 0)]\n        for _ in range(min(beam_width, len(unvisited_nodes))):\n            new_paths = []\n            for last_node, path, cost in paths:\n                for candidate in candidates:\n                    if candidate not in path:\n                        new_cost = cost + distance_matrix[last_node][candidate]\n                        new_paths.append((candidate, path + [candidate], new_cost))\n            paths = sorted(new_paths, key=lambda x: x[2])[:beam_width]\n        return paths[0][0] if paths else None\n    \n    # Step 1: Candidate selection (nearest neighbors + clustering)\n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:5]\n    \n    # Step 2: Look-ahead evaluation with MCTS-inspired simulation\n    scores = {",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    def mst_cost_estimate(nodes):\n        if len(nodes) <= 1:\n            return 0\n        edges = [(distance_matrix[i][j], i, j) for i in nodes for j in nodes if i < j]\n        edges.sort(key=lambda x: x[0])\n        parent = {node: node for node in nodes}\n        rank = {node: 0 for node in nodes}\n        \n        def find(u):\n            while parent[u] != u:\n                parent[u] = parent[parent[u]]\n                u = parent[u]\n            return u\n        \n        def union(u, v):\n            root_u = find(u)\n            root_v = find(v)\n            if root_u != root_v:\n                if rank[root_u] > rank[root_v]:\n                    parent[root_v] = root_u\n                elif rank[root_u] < rank[root_v]:\n                    parent[root_u] = root_v\n                else:\n                    parent[root_v] = root_u\n                    rank[root_u] += 1\n        \n        total_cost = 0\n        for cost, u, v in edges:\n            if find(u) != find(v):\n                union(u, v)\n                total_cost += cost\n        return total_cost\n    \n    def simulate_path(node, remaining_nodes, steps=3):\n        if steps == 0 or len(remaining_nodes) == 0:\n            return 0\n        candidates = sorted(remaining_nodes, key=lambda x: distance_matrix[node][x])[:5]\n        best_score = float('inf')\n        for candidate in candidates:\n            new_remaining = [n for n in remaining_nodes if n != candidate]\n            score = distance_matrix[node][candidate] + simulate_path(candidate, new_remaining, steps - 1)\n            best_score = min(best_score, score)\n        return best_score\n    \n    def beam_search(candidates, beam_width=3):\n        paths = [(current_node, [current_node], 0)]\n        for _ in range(min(beam_width, len(unvisited_nodes))):\n            new_paths = []\n            for last_node, path, cost in paths:\n                for candidate in candidates:\n                    if candidate not in path:\n                        new_cost = cost + distance_matrix[last_node][candidate]\n                        new_paths.append((candidate, path + [candidate], new_cost))\n            paths = sorted(new_paths, key=lambda x: x[2])[:beam_width]\n        return paths[0][0] if paths else None\n    \n    # Step 1: Candidate selection (nearest neighbors + clustering)\n    candidates = sorted(unvisited_nodes, key=lambda x: distance_matrix[current_node][x])[:5]\n    \n    # Step 2: Look-ahead evaluation with MCTS-inspired simulation\n    scores = {}\n    for candidate in candidates:\n        remaining_nodes = [n for n in unvisited_nodes if n != candidate]\n        sim_score = simulate_path(candidate, remaining_nodes)\n        future_mst_cost = mst_cost_estimate(remaining_nodes + [destination_node])\n        scores[candidate] = sim_score + future_mst_cost\n    \n    # Step 3: Beam search for diverse path exploration\n    top_candidates = sorted(scores.keys(), key=lambda x: scores[x])[:3]\n    next_node = beam_search(top_candidates)\n    \n    return next_node",
          "objective": 17.50743,
          "other_inf": null,
          "metadata": {
               "operator": "i1",
               "wisdom_tips": [
                    "Balance local optimization with global solution structure when making decisions",
                    "Use dynamic weighting mechanisms to adapt algorithm behavior based on current state",
                    "Consider the impact of current choices on future decision flexibility"
               ],
               "attention_focus": "balancing local optimality with global search strategies",
               "generation_tendency": "balanced_search",
               "timestamp": 1748364732.259365
          }
     }
]